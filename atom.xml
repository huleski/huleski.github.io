<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Holeski的博客</title>
  
  <subtitle>你为什么这么熟练啊！？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huleski.github.io/"/>
  <updated>2019-09-07T07:33:08.799Z</updated>
  <id>https://huleski.github.io/</id>
  
  <author>
    <name>Holeski</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Springboot解决跨域</title>
    <link href="https://huleski.github.io/2019/09/07/Springboot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"/>
    <id>https://huleski.github.io/2019/09/07/Springboot解决跨域/</id>
    <published>2019-09-07T06:28:47.000Z</published>
    <updated>2019-09-07T07:33:08.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域访问概念"><a href="#跨域访问概念" class="headerlink" title="跨域访问概念"></a>跨域访问概念</h2><blockquote><p>CORS（Cross Origin Resource Sharing）跨域资源共享：表示 JavaScript 代码所在的机器和后端 api 所在的机器不是同一台的情况下实现资源访问。</p></blockquote><p>广义的跨域</p><blockquote><p>资源跳转： A链接、重定向、表单提交</p><p>资源嵌入： <code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;</code>等dom标签</p><p>脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</p></blockquote><p>在前后端分离的项目中，前端一般是 SPA （Single Page Application）类型的应用，所有的 JavaScript 代码都会“下载”到用户机器的浏览器中，后端 api 在服务器端以单个机器或者集群的形式存在。</p><p>同源策略</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a><br><a href="http://www.domain.com/lab/c.js" target="_blank" rel="noopener">http://www.domain.com/lab/c.js</a></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><a href="http://www.domain.com:8000/a.js" target="_blank" rel="noopener">http://www.domain.com:8000/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="https://www.domain.com/b.js" target="_blank" rel="noopener">https://www.domain.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a></td><td>域名和域名对应相同ip</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://x.domain.com/b.js" target="_blank" rel="noopener">http://x.domain.com/b.js</a><br><a href="http://domain.com/c.js" target="_blank" rel="noopener">http://domain.com/c.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.domain1.com/a.js" target="_blank" rel="noopener">http://www.domain1.com/a.js</a><br><a href="http://www.domain2.com/b.js" target="_blank" rel="noopener">http://www.domain2.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、 通过jsonp跨域</span><br><span class="line">2、 document.domain + iframe跨域</span><br><span class="line">3、 location.hash + iframe</span><br><span class="line">4、 window.name + iframe跨域</span><br><span class="line">5、 postMessage跨域</span><br><span class="line">6、 跨域资源共享（CORS）</span><br><span class="line">7、 nginx代理跨域</span><br><span class="line">8、 nodejs中间件代理跨域</span><br><span class="line">9、 WebSocket协议跨域</span><br></pre></td></tr></table></figure><ol><li>通过jsonp跨域</li></ol><p>jquery ajax:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">"handleCallback"</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>vue.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'handleCallback'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jsonp缺点：只能实现get一种请求。</p><ol start="2"><li>跨域资源共享（CORS）</li></ol><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端设置</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>jquery</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>axios</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>java后台设置 (springboot)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持跨域请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Holeski</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019/8/28 9:48</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx反向代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#当前端只跨域不带cookie时，可以为 *</span></span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  </span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到一个非常奇怪的bug是, 在本地按照springboot的方式设置好了, 调试也没问题, 打好jar包放到服务器上就跨域失败, 后来捣鼓了一天找到一个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.dispatch-options-request=true</span><br></pre></td></tr></table></figure><p>设置完就好了, 可是查看源码发现他的默认值就是<code>true</code>。。。。。。后面有时间再仔细看看这个问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跨域访问概念&quot;&gt;&lt;a href=&quot;#跨域访问概念&quot; class=&quot;headerlink&quot; title=&quot;跨域访问概念&quot;&gt;&lt;/a&gt;跨域访问概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CORS（Cross Origin Resource Sharing）跨域资源共享
      
    
    </summary>
    
      <category term="Springboot" scheme="https://huleski.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://huleski.github.io/tags/Springboot/"/>
    
      <category term="跨域" scheme="https://huleski.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7搭建api文档管理工具--YApi</title>
    <link href="https://huleski.github.io/2019/07/29/CentOS7%E6%90%AD%E5%BB%BAapi%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-YApi/"/>
    <id>https://huleski.github.io/2019/07/29/CentOS7搭建api文档管理工具-YApi/</id>
    <published>2019-07-29T12:35:59.000Z</published>
    <updated>2019-08-06T08:53:43.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="YApi简介"><a href="#YApi简介" class="headerlink" title="YApi简介"></a><a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">YApi</a>简介</h2><blockquote><p>YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</p></blockquote><p>国内几大互联网公司都在用的本地api文档管理工具</p><p>环境要求:</p><ul><li>nodejs（7.6+)</li><li>mongodb（2.6+）</li><li>git</li></ul><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>下载nodejs并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.gz</span><br><span class="line">tar -zxf node-v10.16.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑配置文件 <code>vim /etc/profile</code> 在文件最后添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### nodejs environment</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/data/cordova/node-v10.16.0-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使配置立即生效: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>检查node版本命令: <code>node -v</code></p><p>检查npm 版本命令: <code>npm -v</code></p><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2><p>新建一个文件 <code>/etc/yum.repos.d/mongodb-org-4.0.repo</code> 并加入以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 开始安装</span></span><br><span class="line">sudo yum install -y mongodb-org</span><br><span class="line"><span class="comment">## 启动mongo</span></span><br><span class="line">systemctl start mongod</span><br><span class="line"><span class="comment">## 查看版本</span></span><br><span class="line">mongo --version</span><br></pre></td></tr></table></figure><p>修改mongo的配置文件能够远程访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mongod.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line">  # 将下面127.0.0.1换成 0.0.0.0就可以远程访问mongodb了</span><br><span class="line">  bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="全局安装yapi-cli并启动安装程序"><a href="#全局安装yapi-cli并启动安装程序" class="headerlink" title="全局安装yapi-cli并启动安装程序"></a>全局安装yapi-cli并启动安装程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yapi-cli --registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 启动api安装程序</span></span><br><span class="line">yapi server</span><br></pre></td></tr></table></figure><p>浏览器访问: <a href="http://ip:9090" target="_blank" rel="noopener">http://ip:9090</a>, 选择好配置, 点击部署</p><p>如果中途报错: <code>generated/aesprim-browser.js: Permission denied</code>则执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> user 0 </span><br><span class="line">npm config <span class="built_in">set</span> unsafe-perm <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>安装成功会提示: <code>切换到部署目录输入：node vendors/server/app.js</code>, 按照提示去部署目录启动, 再去浏览器访问部署地址就完成了。可是一关闭shell终端yapi会停止运行</p><p>所以我们需要使用pm2来保证进程永远都活着</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pm2</span></span><br><span class="line">npm install pm2 -g</span><br><span class="line"><span class="comment"># pm2启动项目</span></span><br><span class="line">pm2 start vendors/server/app.js --name YApi</span><br><span class="line"><span class="comment"># 显示所有进程状态</span></span><br><span class="line">pm2 list</span><br><span class="line"><span class="comment"># 停止指定的进程</span></span><br><span class="line">pm2 stop 0</span><br><span class="line"><span class="comment"># 杀死指定的进程</span></span><br><span class="line">pm2 delete 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># pm2开机自启动项目 (在此之前先启动项目)</span></span><br><span class="line">pm2 save   <span class="comment"># 保存当前状态</span></span><br><span class="line">pm2 startup   <span class="comment"># 开启自启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用开机自启动</span></span><br><span class="line">pm2 unstartup</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;YApi简介&quot;&gt;&lt;a href=&quot;#YApi简介&quot; class=&quot;headerlink&quot; title=&quot;YApi简介&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/YMFE/yapi&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="YApi" scheme="https://huleski.github.io/categories/YApi/"/>
    
    
      <category term="YApi" scheme="https://huleski.github.io/tags/YApi/"/>
    
  </entry>
  
  <entry>
    <title>cordova入门教程</title>
    <link href="https://huleski.github.io/2019/07/29/cordova%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://huleski.github.io/2019/07/29/cordova入门教程/</id>
    <published>2019-07-29T01:33:23.000Z</published>
    <updated>2019-07-29T12:45:10.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介-Cordova官网-Cordova中文网"><a href="#简介-Cordova官网-Cordova中文网" class="headerlink" title="简介 ( Cordova官网/Cordova中文网)"></a>简介 ( <a href="https://cordova.apache.org/" target="_blank" rel="noopener">Cordova官网</a>/<a href="https://cordova.axuer.com/" target="_blank" rel="noopener">Cordova中文网</a>)</h2><blockquote><p>Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等。</p></blockquote><p>简单来说 Cordova 就是一个能将<code>html/js/css</code>打包成各个平台应用功能的框架, 原理是他内置了一个浏览器, 然后把H5显示出来, 并能够打包成不同平台的App, 目前支持的平台有:</p><ul><li>Android</li><li>Blackberry 10</li><li>iOS</li><li>OS X</li><li>Ubuntu</li><li>Windows</li><li>WP8</li></ul><h2 id="安装环境-data-cordova目录下操作"><a href="#安装环境-data-cordova目录下操作" class="headerlink" title="安装环境 ( /data/cordova目录下操作 )"></a>安装环境 ( /data/cordova目录下操作 )</h2><h3 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h3><p>下载<code>jdk-8u162-linux-x64.tar.gz</code> 并解压到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf jdk-8u162-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑配置文件 <code>vim /etc/profile</code> 在最后添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####  Java environment  #####</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/data/cordova/jdk1.8.0_162</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span>  PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使配置立即生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-安装Android-SDK"><a href="#2-安装Android-SDK" class="headerlink" title="2. 安装Android SDK"></a>2. 安装Android SDK</h3><p>下载 Android SDK并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</span><br><span class="line">tar -xzf android-sdk_r24.4.1-linux.tgz</span><br></pre></td></tr></table></figure><p>编辑配置文件 <code>vim /etc/profile</code> 并在文件最后添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####  Android environment  #####</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/data/cordova/android-sdk-linux</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使配置立即生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>其他可能用到的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 查看可用的组件:</span></span><br><span class="line">android list sdk --all</span><br><span class="line"><span class="comment">### 安装安卓依赖工具包</span></span><br><span class="line">android update sdk -u --all --filter 1,2,3,5,11,12,22,23,24,25,26,27,28,29,45,88,89</span><br></pre></td></tr></table></figure><h3 id="3-安装gradle"><a href="#3-安装gradle" class="headerlink" title="3. 安装gradle"></a>3. 安装gradle</h3><p>在 <code>https://gradle.org/releases/</code> 中复制对应版本gradle下载地址,在/data/cordova中下载并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://services.gradle.org/distributions/gradle-3.3-bin...(替换为你复制的那个下载地址)</span><br><span class="line">unzip  gradle-3.3-linux.zip</span><br></pre></td></tr></table></figure><p>编辑配置: <code>vim /etc/profile</code> 在文件最后添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### gradle environment</span></span><br><span class="line"><span class="built_in">export</span> GRADLE_HOME=/data/cordova/gradle-3.3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GRADLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使配置立即生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4. 安装node.js"></a>4. 安装node.js</h3><p>下载nodejs并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.gz</span><br><span class="line">tar -zxf node-v10.16.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑配置文件 <code>vim /etc/profile</code> 在文件最后添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### nodejs environment</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/data/cordova/node-v10.16.0-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使配置立即生效: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>检查node版本命令: <code>node -v</code><br>检查npm 版本命令: <code>npm -v</code></p><p>最后<code>/etc/profile</code>文件添加的配置为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Java environment</span></span><br><span class="line">JAVA_HOME=/data/gradle/jdk1.8.0_152</span><br><span class="line">CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib/</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH JAVA_HOME CLASSPATH</span><br><span class="line"></span><br><span class="line"><span class="comment">### Nodejs environment</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/data/cordova/node-v8.9.4-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Android environment</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/data/cordova/android-sdk-linux</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$ANDROID_HOME</span>/tools/bin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### gradle environment</span></span><br><span class="line"><span class="built_in">export</span> GRADLE_HOME=/data/cordova/gradle-3.3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GRADLE_HOME</span>/bin</span><br></pre></td></tr></table></figure><h3 id="5-安装Cordova"><a href="#5-安装Cordova" class="headerlink" title="5. 安装Cordova"></a>5. 安装Cordova</h3><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cordova --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="创建Cordova项目"><a href="#创建Cordova项目" class="headerlink" title="创建Cordova项目"></a>创建Cordova项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 可以指定应用ID和应用名: cordova create project_name app_id app_name</span></span><br><span class="line">cordova create hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入项目路径</span></span><br><span class="line"><span class="built_in">cd</span> hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加Android平台</span></span><br><span class="line">cordova platform add android --save</span><br></pre></td></tr></table></figure><p>修改安卓平台构建文件的maven地址为阿里云镜像: <code>vim  platforms/android/build.gradle</code> (可以跳过, 如果构建失败再来配置)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将buildscript和allprojects中repositories 的内容都替换成:</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">"http://maven.aliyun.com/nexus/content/groups/public/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把写好的H5文件放入www文件夹下</p><p>自定义app logo和启动画面需要添加插件 (<a href="https://blog.csdn.net/lc_style/article/details/78401105" target="_blank" rel="noopener">参考文章</a>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova plugin add cordova-plugin-splashscreen</span><br></pre></td></tr></table></figure><p>打包安装App</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova build android</span><br></pre></td></tr></table></figure><p>若打包过程中下载依赖时timeout, 则需要番蔷</p><p>打包成功会出现 <code>BUILD SUCCESSFUL</code> , 打包后的文件为: <code>platforms/android/app/build/outputs/apk/debug/app-debug.apk</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介-Cordova官网-Cordova中文网&quot;&gt;&lt;a href=&quot;#简介-Cordova官网-Cordova中文网&quot; class=&quot;headerlink&quot; title=&quot;简介 ( Cordova官网/Cordova中文网)&quot;&gt;&lt;/a&gt;简介 ( &lt;a href=&quot;
      
    
    </summary>
    
      <category term="cordova" scheme="https://huleski.github.io/categories/cordova/"/>
    
    
      <category term="cordova" scheme="https://huleski.github.io/tags/cordova/"/>
    
  </entry>
  
  <entry>
    <title>tomcat修改session默认的cookie名字</title>
    <link href="https://huleski.github.io/2019/07/17/tomcat%E4%BF%AE%E6%94%B9session%E9%BB%98%E8%AE%A4%E7%9A%84cookie%E5%90%8D%E5%AD%97/"/>
    <id>https://huleski.github.io/2019/07/17/tomcat修改session默认的cookie名字/</id>
    <published>2019-07-17T12:07:08.000Z</published>
    <updated>2019-07-17T12:11:12.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat7修改"><a href="#Tomcat7修改" class="headerlink" title="Tomcat7修改"></a>Tomcat7修改</h2><p>在tomcat的conf目录下, 修改<code>server.xml</code>文件, 在<host>节点中加入<context>配置:</context></host></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">sessionCookiePath</span>=<span class="string">"/"</span> <span class="attr">sessionCookieName</span>=<span class="string">"MY-SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tomcat7修改&quot;&gt;&lt;a href=&quot;#Tomcat7修改&quot; class=&quot;headerlink&quot; title=&quot;Tomcat7修改&quot;&gt;&lt;/a&gt;Tomcat7修改&lt;/h2&gt;&lt;p&gt;在tomcat的conf目录下, 修改&lt;code&gt;server.xml&lt;/code&gt;
      
    
    </summary>
    
      <category term="tomcat" scheme="https://huleski.github.io/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="https://huleski.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Springboot整合Elasticsearch</title>
    <link href="https://huleski.github.io/2019/07/11/Springboot%E6%95%B4%E5%90%88Elasticsearch/"/>
    <id>https://huleski.github.io/2019/07/11/Springboot整合Elasticsearch/</id>
    <published>2019-07-11T12:51:55.000Z</published>
    <updated>2019-07-12T01:11:13.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h2><p>请一定注意版本兼容问题。这关系到很多maven依赖。参考: <a href="https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix" target="_blank" rel="noopener">Spring Data Elasticsearch Spring Boot version matrix</a></p><table><thead><tr><th>Spring Boot Version (x)</th><th>Spring Data Elasticsearch Version (y)</th><th>Elasticsearch Version (z)</th></tr></thead><tbody><tr><td>x &lt;= 1.3.5</td><td>y &lt;= 1.3.4</td><td>z &lt;= 1.7.2*</td></tr><tr><td>x &gt;= 1.4.x</td><td>2.0.0 &lt;=y &lt; 5.0.0**</td><td>2.0.0 &lt;= z &lt; 5.0.0**</td></tr></tbody></table><h2 id="maven依赖-pom-xml"><a href="#maven依赖-pom-xml" class="headerlink" title="maven依赖 pom.xml:"></a>maven依赖 <code>pom.xml</code>:</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置文件application-yml"><a href="#配置文件application-yml" class="headerlink" title=" 配置文件application.yml"></a> 配置文件<code>application.yml</code></h2> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    elasticsearch:</span></span><br><span class="line">      <span class="comment"># 集群名</span></span><br><span class="line"><span class="attr">      cluster-name:</span> <span class="string">syncwt-es</span></span><br><span class="line">      <span class="comment"># 连接节点,注意在集群中通信都是9300端口，否则会报错无法连接上！</span></span><br><span class="line"><span class="attr">      cluster-nodes:</span> <span class="attr">localhost:9300,119.29.38.169:9300</span></span><br><span class="line">      <span class="comment"># 是否本地连接</span></span><br><span class="line"><span class="attr">      local:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      repositories:</span></span><br><span class="line">        <span class="comment"># 仓库中数据存储</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动项目后没有报错，日志出现以下说明代表成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-03-30 19:35:23.078  INFO 20881 --- [           main] o.s.d.e.c.TransportClientFactoryBean     : adding transport node : localhost:9300</span><br></pre></td></tr></table></figure><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"news"</span>, type = <span class="string">"news"</span>, shards = <span class="number">3</span>, replicas = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">News</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Long)</span><br><span class="line">    <span class="keyword">private</span> Long newsId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, searchAnalyzer = <span class="string">"ik_smart"</span>, analyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, searchAnalyzer = <span class="string">"ik_smart"</span>, analyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String summary;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Date, format = DateFormat.custom, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date publishTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String lang;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Date, format = DateFormat.custom, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Date, format = DateFormat.custom, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dao接口可以直接继承spring封装好的接口"><a href="#dao接口可以直接继承spring封装好的接口" class="headerlink" title="dao接口可以直接继承spring封装好的接口"></a>dao接口可以直接继承spring封装好的接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewsRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">News</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;News&gt; <span class="title">findByTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Controller类"><a href="#Controller类" class="headerlink" title="Controller类"></a>Controller类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/es"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NewsRepository newsRepository;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        News news = <span class="keyword">new</span> News();</span><br><span class="line">        news.setId(<span class="string">"1"</span>);</span><br><span class="line">        news.setTitle(<span class="string">"this is a title"</span>);</span><br><span class="line">        news.summary(<span class="string">"China No.1 !!!"</span>);</span><br><span class="line">        news.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        newsRepository.save(news);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        News news = newsRepository.queryById(<span class="string">"1"</span>);</span><br><span class="line">        newsRepository.delete(news);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        News news = newsRepository.queryById(<span class="string">"1"</span>);</span><br><span class="line">        news.setTitle(<span class="string">"哈哈"</span>);</span><br><span class="line">        newsRepository.save(news);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"query"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> News <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        News news = newsRepository.getById(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">return</span> news;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewsRepository已经封装好了基本的增删改查:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">ElasticsearchCrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">index</span><span class="params">(S var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">search</span><span class="params">(QueryBuilder var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">search</span><span class="params">(QueryBuilder var1, Pageable var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">search</span><span class="params">(SearchQuery var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">searchSimilar</span><span class="params">(T var1, String[] var2, Pageable var3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getEntityClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分页排序查询"><a href="#分页排序查询" class="headerlink" title="分页排序查询"></a>分页排序查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持异步查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;News&gt; <span class="title">findByTitle</span><span class="params">(String title)</span></span>;</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder构建查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">    .withQuery(matchAllQuery())</span><br><span class="line">    .withFilter(boolFilter().must(termFilter(<span class="string">"id"</span>, documentId)))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Page&lt;SampleEntity&gt; sampleEntities = elasticsearchTemplate.queryForPage(searchQuery,SampleEntity.class);</span><br></pre></td></tr></table></figure><p>利用Scan和Scroll进行大结果集查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">    .withQuery(matchAllQuery())</span><br><span class="line">    .withIndices(<span class="string">"test-index"</span>)</span><br><span class="line">    .withTypes(<span class="string">"test-type"</span>)</span><br><span class="line">    .withPageable(<span class="keyword">new</span> PageRequest(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    .build();</span><br><span class="line">String scrollId = elasticsearchTemplate.scan(searchQuery,<span class="number">1000</span>,<span class="keyword">false</span>);</span><br><span class="line">List&lt;SampleEntity&gt; sampleEntities = <span class="keyword">new</span> ArrayList&lt;SampleEntity&gt;();</span><br><span class="line"><span class="keyword">boolean</span> hasRecords = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (hasRecords)&#123;</span><br><span class="line">    Page&lt;SampleEntity&gt; page = elasticsearchTemplate.scroll(scrollId, <span class="number">5000L</span> , <span class="keyword">new</span> ResultsMapper&lt;SampleEntity&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Page&lt;SampleEntity&gt; <span class="title">mapResults</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">            List&lt;SampleEntity&gt; chunk = <span class="keyword">new</span> ArrayList&lt;SampleEntity&gt;();</span><br><span class="line">            <span class="keyword">for</span>(SearchHit searchHit : response.getHits())&#123;</span><br><span class="line">                <span class="keyword">if</span>(response.getHits().getHits().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                SampleEntity news = <span class="keyword">new</span> SampleEntity();</span><br><span class="line">                news.setId(searchHit.getId());</span><br><span class="line">                news.setTitle((String)searchHit.getSource().get(<span class="string">"title"</span>));</span><br><span class="line">                chunk.add(news);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PageImpl&lt;SampleEntity&gt;(chunk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(page != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sampleEntities.addAll(page.getContent());</span><br><span class="line">        hasRecords = page.hasNextPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hasRecords = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行封装Util方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Client transportClient = elasticsearchTemplate.getClient();</span><br><span class="line">        News news = <span class="keyword">new</span> News(<span class="number">1</span>, <span class="string">"title"</span>, <span class="string">"content"</span>);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String json = mapper.writeValueAsString(news);</span><br><span class="line">        XContentBuilder builder = jsonBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                .field(<span class="string">"title"</span>, <span class="string">"China No.1"</span>)</span><br><span class="line">                .endObject();</span><br><span class="line"></span><br><span class="line">        IndexResponse response = transportClient.prepareIndex(<span class="string">"es-news"</span>, <span class="string">"news"</span>)</span><br><span class="line">                .setSource(jsonBuilder()</span><br><span class="line">                        .startObject()</span><br><span class="line">                        .field(<span class="string">"title"</span>, <span class="string">"China No.1"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                )</span><br><span class="line">                .execute()</span><br><span class="line">                .actionGet();</span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>spring-data-elasticsearch对es有很好的支持, 我们能通过spring-data很方便地操作Elasticsearch</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本兼容&quot;&gt;&lt;a href=&quot;#版本兼容&quot; class=&quot;headerlink&quot; title=&quot;版本兼容&quot;&gt;&lt;/a&gt;版本兼容&lt;/h2&gt;&lt;p&gt;请一定注意版本兼容问题。这关系到很多maven依赖。参考: &lt;a href=&quot;https://github.com/spri
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>一台机器启动多个tomcat</title>
    <link href="https://huleski.github.io/2019/07/10/%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAtomcat/"/>
    <id>https://huleski.github.io/2019/07/10/一台机器启动多个tomcat/</id>
    <published>2019-07-10T03:43:47.000Z</published>
    <updated>2019-08-12T01:09:11.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>从<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">Apache官网</a>下载好Tomcat, 解压两份到不同的文件夹下即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>第一个tomcat不做任何修改，使用默认端口和配置</p><p>第二个tomcat需要编辑tomcat/conf目录下server.xml文件, 修改3个端口, 使其与前面的tomcat端口不同:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改关闭端口为8015, 第22行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8015"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改服务端口为8081, 第70行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8081"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改连接端口为8019, 第91行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8019"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成, 可以去启动两个tomcat了</p><p>看网上有些说还需要改redirectPort, 设置啥CATALINA_HOME等等, 都是多余的步骤, 完全不用</p><h2 id="指定JDK版本启动tomcat"><a href="#指定JDK版本启动tomcat" class="headerlink" title="指定JDK版本启动tomcat"></a>指定JDK版本启动tomcat</h2><p>有些复杂环境中有多个JDK, 默认会使用系统环境中的<code>JAVA_HOME</code>来启动tomcat, 如需要指定不同JDK版本启动tomcat, 这就需要修改tomcat的启动配置了</p><blockquote><p>在Windows中启动Tomcat时，双击startup.bat然后会调用catalina.bat文件，而catalina.bat会调用setclasspath.bat文件来获取JAVA_HOME和JRE_HOME这两个环境变量的值，因此只要在tomcat启动时指向特定的JDK即可</p></blockquote><ul><li>在Windows中, 需要在<code>setclasspath.bat</code>文件的开头处加入以下内容</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME=C://Program Files/Java/jdk1.<span class="number">7</span>.<span class="number">0</span>_79</span><br><span class="line"><span class="built_in">set</span> JRE_HOME=C://Program Files/Java/jdk1.<span class="number">7</span>.<span class="number">0</span>_79/jre</span><br></pre></td></tr></table></figure><ul><li>在Linux中, 则需要在<code>setclasspath.sh</code>文件的开头处加入以下内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.7.0_79</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/<span class="built_in">local</span>/java/jdk1.7.0_79/jre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Tomcat&quot;&gt;&lt;a href=&quot;#安装Tomcat&quot; class=&quot;headerlink&quot; title=&quot;安装Tomcat&quot;&gt;&lt;/a&gt;安装Tomcat&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://tomcat.apache.org/download-8
      
    
    </summary>
    
      <category term="tomcat" scheme="https://huleski.github.io/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="https://huleski.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建Hexo</title>
    <link href="https://huleski.github.io/2019/07/10/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo/"/>
    <id>https://huleski.github.io/2019/07/10/从零搭建Hexo/</id>
    <published>2019-07-10T03:15:12.000Z</published>
    <updated>2019-07-17T12:11:35.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h2><ul><li><a href="https://blog.yupaits.com/tools/hexo-blog.html#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">使用hexo快速搭建个人博客</a></li><li><a href="https://hoxis.github.io/Hexo+Next%20%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%8D%95%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2.html" target="_blank" rel="noopener">Hexo+Next 添加菜单分类页面</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">NexT主题官网</a></li><li><a href="https://segmentfault.com/a/1190000010058060" target="_blank" rel="noopener">Hexo进阶高级教程</a></li><li><a href="https://segmentfault.com/a/1190000013660164" target="_blank" rel="noopener">hexo搭建个人博客–NexT主题优化</a></li><li><a href="https://www.jianshu.com/p/d34e9531cfce" target="_blank" rel="noopener">Hexo+NexT优化部署</a></li><li><a href="https://asdfv1929.github.io/photos/" target="_blank" rel="noopener">asdfv1929 ‘s Home</a></li><li><a href="https://blog.csdn.net/u012195214/article/details/79204088" target="_blank" rel="noopener">NexT主题的优化定制修改指南</a></li><li><a href="https://www.93bok.com/Hexo%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95%E7%AB%99%E7%82%B9/" target="_blank" rel="noopener">Hexo提交百度和Google收录站点</a></li><li><a href="https://xian6ge.cn/posts/5b8c41e7/" target="_blank" rel="noopener">Hexo NexT 主题6.x版本的使用配置与美化</a></li></ul><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><ul><li>升级主题到Next6, 字体样式失效, 图标也丢失, 启动还会报错 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost/:1 Refused to apply style from <span class="string">'http://localhost:4000/lib/font-awesome/css/font-awesome.min.css?v=4.6.2'</span> </span><br><span class="line">because its MIME <span class="built_in">type</span> (<span class="string">'text/html'</span>) is not a supported stylesheet MIME <span class="built_in">type</span>, and strict MIME checking is enabled.</span><br></pre></td></tr></table></figure><p>在hexo中有自带<code>font-awesome</code>字体的, 但是升级到hexo6时就没有了, 把next目录下（next -&gt; source -&gt; lib）的 <code>font-awesome</code> 文件夹复制到next6同样的目录下, 解决</p><p><img src="http://pubgmjp23.bkt.clouddn.com/%5BD60F5%7D%29IHOGB5%5BW9$T%29F8R.png" alt="font文件夹位置"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章:&quot;&gt;&lt;/a&gt;参考文章:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.yupaits.com/tools/hexo-blog.html
      
    
    </summary>
    
      <category term="Hexo" scheme="https://huleski.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://huleski.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决MySQL数据库Too many connections问题</title>
    <link href="https://huleski.github.io/2019/07/09/%E8%A7%A3%E5%86%B3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Too-many-connections%E9%97%AE%E9%A2%98/"/>
    <id>https://huleski.github.io/2019/07/09/解决MySQL数据库Too-many-connections问题/</id>
    <published>2019-07-09T04:06:05.000Z</published>
    <updated>2019-07-10T01:33:57.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h2><p>因为这种方法是临时修改, 连上MySQL后重启后会失效</p><p>连上MySQL后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> GLOBAL max_connections=500;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改mysql配置文件my.cnf</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在[mysqld]段中添加或修改max_connections值</span></span><br><span class="line">max_connections=500</span><br><span class="line"><span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><ul><li>查看mysql的最大连接数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%max_connections%'</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections |  500  |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>查询所有连接到这个服务器上的MySQL连接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><p>获取到MySQL数据连接列表后，每一条记录都会有一个进程ID号（在上表的第一列）。执行以下命令关闭一条连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中1180421是进程列表里找到并且要杀掉的进程号</span></span><br><span class="line">mysql&gt; <span class="built_in">kill</span> 1180421;</span><br></pre></td></tr></table></figure><ul><li>查看服务器响应的最大连接数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">'Max_used_connections'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一:&quot;&gt;&lt;/a&gt;方法一:&lt;/h2&gt;&lt;p&gt;因为这种方法是临时修改, 连上MySQL后重启后会失效&lt;/p&gt;
&lt;p&gt;连上MySQL后执行:&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="MySQL" scheme="https://huleski.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://huleski.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>docker安装JIRA和Confluence（破解版）以及JIRA版本升级方案</title>
    <link href="https://huleski.github.io/2019/07/08/docker%E5%AE%89%E8%A3%85JIRA%E5%92%8CConfluence%EF%BC%88%E7%A0%B4%E8%A7%A3%E7%89%88%EF%BC%89%E4%BB%A5%E5%8F%8AJIRA%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%96%B9%E6%A1%88/"/>
    <id>https://huleski.github.io/2019/07/08/docker安装JIRA和Confluence（破解版）以及JIRA版本升级方案/</id>
    <published>2019-07-08T08:41:58.000Z</published>
    <updated>2019-07-17T12:11:22.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将演示通过Docker安装JIRA和Confluence，并破解过程。<br>本文只做个人学习研究之用，不得用于商业用途！</p></blockquote><h2 id="安装JIRA-7-12-3"><a href="#安装JIRA-7-12-3" class="headerlink" title="安装JIRA (7.12.3)"></a>安装JIRA (7.12.3)</h2><h3 id="1-获取资源"><a href="#1-获取资源" class="headerlink" title="1. 获取资源"></a>1. 获取资源</h3><ul><li>Docker镜像 <a href="https://github.com/cptactionhank" target="_blank" rel="noopener">Github链接</a></li><li>补丁工具(atlassian-agent.jar) <a href="https://github.com/pengzhile/atlassian-agent/releases/download/v1.2/atlassian-agent-v1.2.zip" target="_blank" rel="noopener">Github链接</a>  原链接已失效, 附百度云:</li></ul><blockquote><p>百度网盘地址：</p><p>链接：<a href="https://pan.baidu.com/s/17zNwlp3sd1PLSCxPVjDwfQ" target="_blank" rel="noopener">https://pan.baidu.com/s/17zNwlp3sd1PLSCxPVjDwfQ</a> </p><p>提取码：b84z </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><h3 id="2-制作Docker破解容器"><a href="#2-制作Docker破解容器" class="headerlink" title="2. 制作Docker破解容器"></a>2. 制作Docker破解容器</h3><p>编写Dockerfile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM cptactionhank/atlassian-jira-software:7.12.3</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代理破解包加入容器</span></span><br><span class="line">COPY <span class="string">"atlassian-agent.jar"</span> /opt/atlassian/jira/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动加载代理包</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'export CATALINA_OPTS="-javaagent:/opt/atlassian/jira/atlassian-agent.jar $&#123;CATALINA_OPTS&#125;"'</span> &gt;&gt; /opt/atlassian/jira/bin/setenv.sh</span><br></pre></td></tr></table></figure><p>将下载好的<code>atlassian-agent.jar</code>文件放在Dockerfile同目录下，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- JIRA</span><br><span class="line">    |-Dockerfile</span><br><span class="line">    |-atlassian-agent.jar</span><br></pre></td></tr></table></figure><p>构建镜像, 执行命令(注意后面有一个点)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t jira/jira:v7.12.3 .</span><br></pre></td></tr></table></figure><p>构建成功后会显示 ‘Successfully built…` 字样</p><p>启动容器，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 10086:8080 \</span><br><span class="line">    -v /home/jira/data:/var/atlassian/jira \</span><br><span class="line">    --restart always --name=jira \</span><br><span class="line">    --health-cmd=<span class="string">"curl --silent --fail localhost:8080 || exit 1"</span> \</span><br><span class="line">    jira/jira:v7.12.3</span><br></pre></td></tr></table></figure><p>访问: `<a href="http://127.0.0.1:10086,可见JIRA配置页面" target="_blank" rel="noopener">http://127.0.0.1:10086,可见JIRA配置页面</a></p><h3 id="3-破解"><a href="#3-破解" class="headerlink" title="3. 破解"></a>3. 破解</h3><p>在见到JIRA配置页面后, 进行相关配置, 当要求输入许可证时</p><p><img src="http://pubgmjp23.bkt.clouddn.com/10973635-4168e67779acb0b2_%E7%9C%8B%E5%9B%BE%E7%8E%8B.web.jpg" alt="进入JIRA配置页面"></p><p>复制服务器ID: <code>BY9B-GWD1-1C78-K2DE</code>, 在存放<code>atlassian-agent.jar</code>的目录下执行命令, 生成许可证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需替换邮箱（test@test.com）、名称（JIRA）、</span></span><br><span class="line"><span class="comment"># 访问地址（http://192.168.0.1）、服务器ID（BY9B-GWD1-1C78-K2DE）</span></span><br><span class="line"><span class="comment"># 为你的信息</span></span><br><span class="line"></span><br><span class="line">java -jar atlassian-agent.jar -d -m <span class="built_in">test</span>@test.com -n JIRA -p jira -o http://192.168.0.89 -s BY9B-GWD1-1C78-K2DE</span><br></pre></td></tr></table></figure><p><img src="http://pubgmjp23.bkt.clouddn.com/xukezheng.jpg" alt="生成许可证"></p><p>复制下面生成的一长串许可证填写到页面中, 完成破解</p><h2 id="安装-Confluence（6-14-1"><a href="#安装-Confluence（6-14-1" class="headerlink" title="安装 Confluence（6.14.1)"></a>安装 Confluence（6.14.1)</h2><h3 id="1-编写Dockerfile文件"><a href="#1-编写Dockerfile文件" class="headerlink" title="1. 编写Dockerfile文件"></a>1. 编写Dockerfile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM cptactionhank/atlassian-confluence:6.14.1</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代理破解包加入容器</span></span><br><span class="line">COPY <span class="string">"atlassian-agent.jar"</span> /opt/atlassian/confluence/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动加载代理包</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'export CATALINA_OPTS="-javaagent:/opt/atlassian/confluence/atlassian-agent.jar $&#123;CATALINA_OPTS&#125;"'</span> &gt;&gt; /opt/atlassian/confluence/bin/setenv.sh</span><br></pre></td></tr></table></figure><h3 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2. 构建镜像"></a>2. 构建镜像</h3><p>将下载好的<code>atlassian-agent.jar</code>文件放在Dockerfile同目录下，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Confluence</span><br><span class="line">    |-Dockerfile</span><br><span class="line">    |-atlassian-agent.jar</span><br></pre></td></tr></table></figure><p>构建镜像, 执行命令(注意后面有一个点)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t confluence/confluence:v6.14.1 .</span><br></pre></td></tr></table></figure><p>启动容器，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 10087:8080 \</span><br><span class="line">  -v /home/confluence/data:/var/atlassian/confluence \</span><br><span class="line">  --restart always --name=confluence \</span><br><span class="line">  --health-cmd=<span class="string">"curl --silent --fail localhost:8080 || exit 1"</span> \</span><br><span class="line">  confluence/confluence:v6.14.1</span><br></pre></td></tr></table></figure><p>访问<code>http://127.0.0.1:8090</code>,参照JIRA的安装流程，进行操作。</p><p>生成confluence许可方法可参照前面JIRA的破解过程, 这里不再赘述</p><h2 id="JIRA版本升级"><a href="#JIRA版本升级" class="headerlink" title="JIRA版本升级"></a>JIRA版本升级</h2><p>可以参考<a href="https://confluence.atlassian.com/jirakb/startup-check-jira-data-version-too-low-to-be-upgraded-872266914.html" target="_blank" rel="noopener">官方文档</a></p><p><img src="http://pubgmjp23.bkt.clouddn.com/jira.png" alt="升级步骤"></p><p>由于之前安装的是jira6.4版本的, 现在需要升级到7.12.3版本, 根据官方提示需要先升级到7.0版本的jira再过渡升级到7.12.3</p><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1. 备份数据"></a>1. 备份数据</h3><p><strong>a. 备份数据库</strong></p><p>登录jira6.4版本, 进入设置 -&gt; 系统 -&gt; 备份系统, 输入备份的文件名字: 比如jira</p><p><img src="http://pubgmjp23.bkt.clouddn.com/2E6%7D47Y%29@KMCUP3%25%295B%29%60%7BO.png" alt="备份系统"></p><p>点击备份后会在备份界面提示的某个路径下生成一个<code>jira.zip</code>数据库的备份文件</p><p><strong>b . 备份图片</strong></p><p>复制 <code>/var/atlassian/application-data/jira/data</code>下的<code>attachments</code>和<code>avatars</code>文件夹出来,备份好</p><h3 id="2-升级过渡版"><a href="#2-升级过渡版" class="headerlink" title="2. 升级过渡版"></a>2. 升级过渡版</h3><p>如果不过数据库文件过渡处理, 在jira v7.12.3中是无法使用的</p><p>获取JIRA v7.0.11 镜像并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull dchevell/jira-software:7.0.11</span><br><span class="line">docker run -d -p 8080:8080 dchevell/jira-software:7.0.11</span><br></pre></td></tr></table></figure><p>启动后访问 <code>http://127.0.0.1:8080</code>, 开始配置, 当需要许可证时, 上面的方法破解不了, 由于只是做一个过度版本, 可以去官网注册然后申请一个30天有效期的许可证, 然后输入进去就好了</p><p>同样在备份系统的同级目录中点击恢复系统</p><p><img src="http://pubgmjp23.bkt.clouddn.com/ertysdysdrtysert.png" alt="恢复系统"></p><p>按照提示将前面备份好的文件放到他指定目录下,点击复原, 如果需要填写许可证那就填写许可证在复原</p><p>复原成功后再重复上一步骤进行备份<br>备份后将在 docker容器 <code>/var/atlassian/jira/export</code>目录下生成一个<code>.zip</code>数据库的备份文件</p><h3 id="3-升级最终版"><a href="#3-升级最终版" class="headerlink" title="3. 升级最终版"></a>3. 升级最终版</h3><p>按照上面的步骤把jira v7.12.3运行起来, 并将数据库备份文件放入恢复界面指定的目录之下进行数据复原.</p><p>把前面图片备份文件分别放入<code>/var/atlassian/application-data/jira/data/</code>下即可</p><p>升级成功!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文将演示通过Docker安装JIRA和Confluence，并破解过程。&lt;br&gt;本文只做个人学习研究之用，不得用于商业用途！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装JIRA-7-12-3&quot;&gt;&lt;a href=&quot;#安装JIRA-7-
      
    
    </summary>
    
      <category term="JIRA" scheme="https://huleski.github.io/categories/JIRA/"/>
    
    
      <category term="JIRA" scheme="https://huleski.github.io/tags/JIRA/"/>
    
      <category term="docker" scheme="https://huleski.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>初识JMX</title>
    <link href="https://huleski.github.io/2019/06/15/%E5%88%9D%E8%AF%86JMX/"/>
    <id>https://huleski.github.io/2019/06/15/初识JMX/</id>
    <published>2019-06-15T12:47:00.000Z</published>
    <updated>2019-06-18T12:50:00.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JXM简介"><a href="#JXM简介" class="headerlink" title="JXM简介"></a>JXM简介</h2><p>试想，一个正在运行中的程序，我们如果想改变程序中的一些属性，可以通过什么方法呢？可能有这么几个方法：</p><ul><li>对于服务器式的程序，可以制作管理页面，通过HTTP post与servlet来更改服务器端程序的属性。</li><li>对于服务器式的程序，还可以通过SOAP方式。但这需要程序开启了SOAP端的服务。</li><li>可以使用RMI远程调用。但这需要设计开启RMI服务。</li><li>如果是SWT或Swing的程序，则可以通过设计UI管理界面，使用户可以和程序内部交互。</li><li>还有一种方式，是将可改变的属性放入配置文件XML，properties或数据库，程序轮询配置文件，以求获取最新的配置。</li></ul><p>上面几个方法都是常见，但却无法通用的。所谓通用，是指解决方案符合一个标准，使得任何符合此标准的工具都能解析针对此标准的方案实现。这样A公司设计的方案，B公司可以根据标准来解析。JMX就是Java管理标准。</p><p>对于一些参数的修改，网上有一段描述还是比较形象的：</p><ol><li>程序初哥一般是写死在程序中，到要改变的时候就去修改代码，然后重新编译发布。</li><li>程序熟手则配置在文件中（JAVA一般都是properties文件），到要改变的时候只要修改配置文件，但还是必须重启系统，以便读取配置文件里最新的值。</li><li>程序好手则会写一段代码，把配置值缓存起来，系统在获取的时候，先看看配置文件有没有改动，如有改动则重新从配置里读取，否则从缓存里读取。</li><li>程序高手则懂得物为我所用，用JMX把需要配置的属性集中在一个类中，然后写一个MBean，再进行相关配置。另外JMX还提供了一个工具页，以方便我们对参数值进行修改。</li></ol><p>JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。JMX让程序有被管理的功能，例如你开发一个WEB网站，它是在24小时不间断运行，那么你肯定会对网站进行监控，如每天的UV、PV是多少；又或者在业务高峰的期间，你想对接口进行限流，就必须去修改接口并发的配置值。</p><p>应用场景：中间件软件WebLogic的管理页面就是基于JMX开发的，而JBoss则整个系统都基于JMX构架。</p><h2 id="JMX的构成"><a href="#JMX的构成" class="headerlink" title="JMX的构成"></a>JMX的构成</h2><p>JMX由三部分组成：</p><ul><li><p>基础层：程序端的Instrumentation, 我把它翻译成可操作的仪器。这部分就是指的MBean. MBean类似于JavaBean。最常用的MBean则是Standard MBean和MXBean.</p></li><li><p>适配层：程序端的JMX agent. 这部分指的是MBean Server. MBean Server则是启动与JVM内的基于各种协议的适配器。用于接收客户端的调遣，然后调用相应的MBeans.</p></li><li><p>接入层：客户端的Remote Management. 这部分则是面向用户的程序。此程序则是MBeans在用户前投影，用户操作这些投影，可以反映到程序端的MBean中去。这内部的原理则是client通过某种协议调用agent操控MBeans.<br>JMX agent与Remote Management之间是通过协议链接的，这协议可能包含：</p><ul><li>HTTP</li><li>SNMP</li><li>RMI</li><li>IIOP</li></ul></li></ul><p>JMX agent中有针对上面协议的各种适配器。可以解析通过相应协议传输过来的数据。Remote Management client则可以用现成的工具，如JConsole, 也可以自己书写java code。</p><h2 id="实现一个JMX程序"><a href="#实现一个JMX程序" class="headerlink" title="实现一个JMX程序"></a>实现一个JMX程序</h2><p> 1、 首先定义一个MBean接口，接口的命名规范为以具体的实现类为前缀（这个规范很重要）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloMBean</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">(String str)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTelephone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义一个实现类，实现上面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该类名称必须与实现的接口的前缀保持一致（即MBean前面的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">HelloMBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get Telephone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloWorld:"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get name 123"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"set name 123"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get age 123"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"set age 123"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义agent层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> javax.management.JMException;</span><br><span class="line"><span class="keyword">import</span> javax.management.MBeanServer;</span><br><span class="line"><span class="keyword">import</span> javax.management.ObjectName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMException, Exception </span>&#123;</span><br><span class="line">          <span class="comment">// 通过工厂类获取MBeanServer，用来做MBean的容器 </span></span><br><span class="line">         MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">          <span class="comment">// ObjectName中的取名是有一定规范的，格式为：“域名：name=MBean名称”，其中域名和MBean的名称可以任意取。</span></span><br><span class="line">         ObjectName helloName = <span class="keyword">new</span> ObjectName(<span class="string">"jmxBean:name=hello"</span>);</span><br><span class="line">         <span class="comment">//将Hello这个类注入到MBeanServer中，注入需要创建一个ObjectName类</span></span><br><span class="line">         server.registerMBean(<span class="keyword">new</span> Hello(), helloName);</span><br><span class="line">         Thread.sleep(<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的JMX的DEMO已经写完了，现在我们通过JDK提供的Jconsole来进行操作。</p><p>4、在JDK安装路径 ·JAVA_HOME\bin· 下找到 jconsole.exe 这个小工具，双击打开。</p><p>在本地进程中找到 <code>HelloAgent</code> 并双击打开</p><p>在当前界面上，我们可以给程序中HelloMBean的属性赋值，也可以调用其中的方法</p><p>这样就做到动态修改运行中程序的状态进而管理程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JXM简介&quot;&gt;&lt;a href=&quot;#JXM简介&quot; class=&quot;headerlink&quot; title=&quot;JXM简介&quot;&gt;&lt;/a&gt;JXM简介&lt;/h2&gt;&lt;p&gt;试想，一个正在运行中的程序，我们如果想改变程序中的一些属性，可以通过什么方法呢？可能有这么几个方法：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="JMX" scheme="https://huleski.github.io/categories/JMX/"/>
    
    
      <category term="JMX" scheme="https://huleski.github.io/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>java爬虫-webmagic入门</title>
    <link href="https://huleski.github.io/2019/06/14/java%E7%88%AC%E8%99%AB-webmagic%E5%85%A5%E9%97%A8/"/>
    <id>https://huleski.github.io/2019/06/14/java爬虫-webmagic入门/</id>
    <published>2019-06-14T10:48:13.000Z</published>
    <updated>2019-07-06T03:18:34.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webmagic简介"><a href="#webmagic简介" class="headerlink" title="webmagic简介"></a>webmagic简介</h2><p><img src="https://camo.githubusercontent.com/8b3a6d93d95d39147ef93f5021f6b69255bda888/687474703a2f2f7765626d616769632e696f2f696d616765732f6c6f676f2e6a706567" alt="webmagic"></p><p><a href="http://webmagic.io/" target="_blank" rel="noopener">官方网站</a> </p><blockquote><p>webmagic是一个开源的Java垂直爬虫框架，目标是简化爬虫的开发流程，让开发者专注于逻辑功能的开发。webmagic的核心非常简单，但是覆盖爬虫的整个流程，也是很好的学习爬虫开发的材料。</p></blockquote><p>webmagic的主要特色：</p><ul><li>完全模块化的设计，强大的可扩展性。</li><li>核心简单但是涵盖爬虫的全部流程，灵活而强大，也是学习爬虫入门的好材料。</li><li>提供丰富的抽取页面API。</li><li>无配置，但是可通过POJO+注解形式实现一个爬虫。</li><li>支持多线程。</li><li>支持分布式。</li><li>支持爬取js动态渲染的页面。</li><li>无框架依赖，可以灵活的嵌入到项目中去。</li></ul><p>该项目是参考了:</p><p><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">python爬虫 scrapy</a></p><p><a href="http://git.oschina.net/l-weiwei/spiderman" target="_blank" rel="noopener">Java爬虫 Spiderman</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>webmagic使用maven管理依赖，在项目中添加对应的依赖即可使用webmagic：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>us.codecraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webmagic-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>us.codecraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webmagic-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意: </strong> 这里都是参考官方文档, 但实际上maven库的包源有bug, 不过作者已经在源代码里修复了, 需要copy源代码重新编译打包</p><p>克隆源代码 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/code4craft/webmagic.git</span><br></pre></td></tr></table></figure><p>或者直接下载zip源码压缩包, 下载完解压即可</p><p>下载完成后导入到开发工具中, 重新 install webmagic-core模块即可</p><p>创建第一个爬虫:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GithubRepoPageProcessor</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分一：抓取网站的相关配置，包括编码、抓取间隔、重试次数等</span></span><br><span class="line">    <span class="keyword">private</span> Site site = Site.me().setRetryTimes(<span class="number">3</span>).setSleepTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// process是定制爬虫逻辑的核心接口，在这里编写抽取逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 部分二：定义如何抽取页面信息，并保存下来</span></span><br><span class="line">        page.putField(<span class="string">"author"</span>, page.getUrl().regex(<span class="string">"https://github\\.com/(\\w+)/.*"</span>).toString());</span><br><span class="line">        page.putField(<span class="string">"name"</span>, page.getHtml().xpath(<span class="string">"//h1[@class='entry-title public']/strong/a/text()"</span>).toString());</span><br><span class="line">        <span class="keyword">if</span> (page.getResultItems().get(<span class="string">"name"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//skip this page</span></span><br><span class="line">            page.setSkip(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.putField(<span class="string">"readme"</span>, page.getHtml().xpath(<span class="string">"//div[@id='readme']/tidyText()"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 部分三：从页面发现后续的url地址来抓取</span></span><br><span class="line">        page.addTargetRequests(page.getHtml().links().regex(<span class="string">"(https://github\\.com/[\\w\\-]+/[\\w\\-]+)"</span>).all());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> site;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Spider.create(<span class="keyword">new</span> GithubRepoPageProcessor())</span><br><span class="line">                <span class="comment">//从"https://github.com/code4craft"开始抓</span></span><br><span class="line">                .addUrl(<span class="string">"https://github.com/code4craft"</span>)</span><br><span class="line">                <span class="comment">//开启5个线程抓取</span></span><br><span class="line">                .thread(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">//启动爬虫</span></span><br><span class="line">                .run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行, 就能看到爬虫工作了</p><p>如果运行的时候报错 <code>javax.net.ssl.SSLException: Received fatal alert: protocol_version</code> 那是你没有编译源码打包.</p><p>代码中注释已经很详细了, 相信大家也大概明白爬取的过程了. 更详细的爬虫教程看作者的<a href="http://webmagic.io/docs/" target="_blank" rel="noopener">官方教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webmagic简介&quot;&gt;&lt;a href=&quot;#webmagic简介&quot; class=&quot;headerlink&quot; title=&quot;webmagic简介&quot;&gt;&lt;/a&gt;webmagic简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubuserconte
      
    
    </summary>
    
      <category term="爬虫" scheme="https://huleski.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://huleski.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下几个有趣的命令</title>
    <link href="https://huleski.github.io/2019/05/20/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>https://huleski.github.io/2019/05/20/Linux系统下几个有趣的命令/</id>
    <published>2019-05-20T11:51:12.000Z</published>
    <updated>2019-05-20T12:22:23.509Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。今天我们就来介绍几个有趣的Linux命令, 来体验一波程序彩蛋之美。</p><p>文章参考: <a href="https://www.jianshu.com/p/08e9094f61ce" target="_blank" rel="noopener">Linux系统下好玩有趣的命令，你又用过几个？</a></p><p>由于原文都是在Ubuntu系统下安装使用的, 而我自己是在CentOS7系统下操作, 偶尔有些不同, 我也只选择了其中几个很有趣的试了试</p><h2 id="sl-（Steam-Locomotive）"><a href="#sl-（Steam-Locomotive）" class="headerlink" title="sl （Steam Locomotive）"></a>sl （Steam Locomotive）</h2><p>安装, 这个是最简单的, 经常在你想要查看当前目录的时候错误的输入了<code>sl</code>, 现在就回出现一辆小火车开过的动画…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sl</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl</span><br></pre></td></tr></table></figure><h2 id="oneko"><a href="#oneko" class="headerlink" title="oneko"></a>oneko</h2><p>撸猫指令, oneko会生成一只图像猫, 在屏幕上乱跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install oneko</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneko</span><br></pre></td></tr></table></figure><h2 id="cmatrix"><a href="#cmatrix" class="headerlink" title="cmatrix"></a>cmatrix</h2><p>该指令会在屏幕上下一场字符雨</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 下载压缩包</span></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz</span><br><span class="line"><span class="comment">## 解压</span></span><br><span class="line">tar xvf cmatrix-1.2a.tar.gz</span><br><span class="line"><span class="comment">## 进入安装目录</span></span><br><span class="line"><span class="built_in">cd</span> cmatrix-1.2a</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">yum install ncurses-devel</span><br><span class="line"><span class="comment">## 编译源码并安装, 需要有gcc,gcc-c++, 如果没有就yum安装</span></span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="comment">## 安装完毕, 运行</span></span><br><span class="line">cmatrix</span><br></pre></td></tr></table></figure><p>启动成功后, 有看到字符雨, 按<code>q</code>退出</p><h2 id="ASCIIquarium"><a href="#ASCIIquarium" class="headerlink" title="ASCIIquarium"></a>ASCIIquarium</h2><p>彩蛋：把你的linux终端变成一个海洋世界，各种生物在不断呈现，有鱼、有水、有草…, 好鬼酷哦(wzr…)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装依赖工具</span></span><br><span class="line">yum -y install ncurses-devel perl-CPAN libyaml-devel perl-CGI perl-Curses perl-ExtUtils-MakeMaker</span><br><span class="line"><span class="comment">## 安装依赖文件</span></span><br><span class="line">wget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gz</span><br><span class="line">tar -zxvf Term-Animation-2.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> Term-Animation-2.4/</span><br><span class="line">perl Makefile.PL &amp;&amp; make</span><br><span class="line">make install</span><br><span class="line"><span class="comment">## 安装ASCIIquarium</span></span><br><span class="line">wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gz</span><br><span class="line">tar -zxvf asciiquarium.tar.gz</span><br><span class="line"><span class="built_in">cd</span> asciiquarium_1.1/</span><br><span class="line">cp asciiquarium /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">chmod 755 /usr/<span class="built_in">local</span>/bin/asciiquarium</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">asciiquarium</span><br></pre></td></tr></table></figure><p>同样的运行成功后按<code>q</code>退出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。今天我们就来介绍几个有趣的Linux命令, 来体验一
      
    
    </summary>
    
      <category term="Linux" scheme="https://huleski.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://huleski.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>QQ/微信机器人的安装使用</title>
    <link href="https://huleski.github.io/2019/05/12/QQ-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://huleski.github.io/2019/05/12/QQ-微信机器人的安装使用/</id>
    <published>2019-05-12T08:39:47.000Z</published>
    <updated>2019-07-11T12:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常在微信/QQ上看到可以自动聊天的机器人, 感觉很有趣, 今天我们就可以来创建这样一个机器人. </p><p><strong>前期准备</strong>: </p><blockquote><p>在<a href="http://www.tuling123.com" target="_blank" rel="noopener">图灵机器人网站</a>上注册一个账号, 注册成功后在网站上创建一个机器人, 勾选qq/微信即可, 创建完成后会有一个apikey, 记住这个apikey, 后面会用到. </p></blockquote><p><strong>图灵机器人的作用</strong>: </p><blockquote><p>在聊天机器人中, 当我们发送消息给机器人账号时, 机器人账号会将获取到的消息通过apikey发到图灵机器人网站上, 然后图灵机器人背后使用机器学习+大数据分析相结合的人工智能技术得出消息的回复, 并把该回复响应给机器人账号,进而呈现在你的屏幕上, 这就是整个聊天机器人的工作原理</p></blockquote><blockquote><p>注册好图灵机器人账号后, 它会免费提供给我们每天100次的调用次数, 也就是说他可以每天跟我们对话100次, 如果你觉得少了也可以升级到收费版, 调用次数会大幅提升.</p></blockquote><h1 id="微信机器人"><a href="#微信机器人" class="headerlink" title="微信机器人"></a>微信机器人</h1><p>参考<a href="https://github.com/pig6/wxrobot" target="_blank" rel="noopener">项目</a>, 该项目使用python3来运行的, 因此我们先安装python3, 去<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python官网</a>下载, 这里我选择Windows版本, 安装的时候有个地方<code>add to path</code> 需要勾选, 其他都点下一步就安装好了.<br>验证是否安装成功, 在CMD命令行窗口里输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><p>如果输出版本号, 则表示安装成功</p><p><a href="https://github.com/pig6/wxrobot" target="_blank" rel="noopener">从github下载项目源码</a></p><p>下载后进入项目目录,当前目录下应该可以看到<code>robot.py</code>文件, 如果是下载zip包则先解压缩</p><p>安装依赖文件, 打开CMD窗口输入下面命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -U wxpy -i <span class="string">"https://pypi.doubanio.com/simple/"</span></span><br></pre></td></tr></table></figure><p>等依赖安装结束后, 启动项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python robot.py</span><br></pre></td></tr></table></figure><p>此时会出现一个登陆用的二维码, 用手机微信扫码登陆, 登陆成功后会提示登陆成功, 这样一个微信机器人就创建成功了, 试着发消息给这个微信号, 和他聊聊天吧!</p><p><strong>注意</strong>: </p><ul><li>如果在扫码登陆的时候报错, 很可能是因为你使用了新申请的微信, 腾讯为了安全考虑做出的新号登录限制, 一个号是否可以用来作为机器人账号, 可以先试着登陆<a href="https://wx.qq.com/" target="_blank" rel="noopener">网页版微信</a>成功与否来判断, 因为该项目的原理就是使用了网页端微信的api来收发消息的</li><li>该项目里使用了原作者自己提供的图灵机器人apikey, 可能由于使用次数达到限制而无法自动回复, 此时我们应该使用自己图灵账号的apikey了, 打开 <code>config.py</code> , 修改里面 <code>tuling_api_key</code> 这一项的值为自己的apikey.</li></ul><h1 id="QQ机器人"><a href="#QQ机器人" class="headerlink" title="QQ机器人"></a>QQ机器人</h1><h2 id="酷Q"><a href="#酷Q" class="headerlink" title="酷Q"></a>酷Q</h2><p>酷Q是一款免费的qq机器人, 以前是基于webqq、smartQQ协议做的自动收发消息功能, 但现在腾讯已经放弃了网页版的qq, 也就是以前的webqq、smartQQ协议都不行了。后来听说酷Q按照安卓的qq协议反编译出的，因此最新版应该是基于安卓协议的。</p><h2 id="下载Windows版安装"><a href="#下载Windows版安装" class="headerlink" title="下载Windows版安装"></a>下载Windows版安装</h2><p>从<a href="https://cqp.cc/t/23253" target="_blank" rel="noopener">酷Q官网</a>下载软件压缩包，直接解压运行即可，此时会要求登录qq账号来作为机器人账号，建议使用小号来登录。登录完成后，会有提示下一步如何操作，根据提示完成后就可以大致明白如何使用QQ机器人的聊天等功能了。如需启用图灵机器人, 设置图灵的apikey后就可以聊天了.</p><p>这是最基本的功能，他还有一个强大之处在于，他的插件扩展功能更强大</p><p>在酷Q的<a href="https://cqp.cc/b/app" target="_blank" rel="noopener">应用官网</a>，插件在酷Q官网叫应用，选择一个应用下载吧（需要注册登录），下载完后缀名是cpk的文件后，直接放入酷Q安装目录的app文件夹中，重启酷Q就可以加载进去，然后就可以体验机器人的乐趣了。</p><h2 id="安装Linux版"><a href="#安装Linux版" class="headerlink" title="安装Linux版"></a>安装Linux版</h2><p>一般也不会挂着机器人在Windows上，所以如果我们有linux服务器，就比较好挂着机器人了。</p><p>这里使用的Docker安装酷Q，详细查看<a href="https://cqp.cc/t/34558" target="_blank" rel="noopener">官网介绍</a></p><p>首先确保Linux已经装好Docker了，接下来拉取镜像运行就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>然后运行 酷Q 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=coolq --rm -p 9000:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=123456 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>运行后，会看到控制台中输出一系列日志。当你看到 <code>[CQDaemon] Started CoolQ</code>  时，说明已启动成功。<br>此时，在浏览器中访问 <code>http://你的服务器IP:9000</code> 即可看到远程操作登录页面，输入密码123456，即可看到 酷Q Air 的登录界面啦。<br>在登录后，右键点击悬浮窗 -&gt; 昵称 -&gt; 勾选「自动登录」，即可保证 酷Q 能自动登录。</p><p>这时候如果关闭linux界面酷Q就会停了, 所以我们需要后台运行酷Q:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=coolq -d -p 9000:9000 --restart always -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=123456 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>查看运行状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs coolq</span><br></pre></td></tr></table></figure><p>启动/停止服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start coolq</span><br><span class="line">docker stop coolq</span><br></pre></td></tr></table></figure><p>如果想安装插件, 把插件放入挂载的文件<code>/root/coolq-data/app</code>, 重启酷Q即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经常在微信/QQ上看到可以自动聊天的机器人, 感觉很有趣, 今天我们就可以来创建这样一个机器人. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前期准备&lt;
      
    
    </summary>
    
      <category term="机器人" scheme="https://huleski.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="机器人" scheme="https://huleski.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装Elasticsearch</title>
    <link href="https://huleski.github.io/2019/05/06/CentOS7%E5%AE%89%E8%A3%85Elasticsearch/"/>
    <id>https://huleski.github.io/2019/05/06/CentOS7安装Elasticsearch/</id>
    <published>2019-05-06T03:37:41.000Z</published>
    <updated>2019-08-29T00:32:29.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>Elasticsearch 目前有三个常用的稳定的主版本：2.x，5.x，6.x, 目前最新是7.0.0</p><blockquote><p>中间没有3.x和4.x是为了ELK（ElasticSearch, logstash, kibana）技术栈的版本统一，免的给用<br>户带来混乱。</p></blockquote><p>版本选择可以从以下几个方面考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">版本问题</span><br><span class="line">2.x 版本较老，无法体验新功能，且性能不如 5.x。</span><br><span class="line">6.x 版本有点新，网上资料相对比较少（开发时间充足的可以研究）。</span><br><span class="line"></span><br><span class="line">数据迁移</span><br><span class="line">2.x 版本数据可以直接迁移到 5.x；</span><br><span class="line">5.X 版本的数据可以直接迁移到 6.x； 但是 2.x 版本数据无法直接迁移到 6.x。</span><br><span class="line"></span><br><span class="line">周边工具</span><br><span class="line">2.x 版本周边工具版本比较混乱；Kibana 等工具的对应版本需要自己查，不好匹配。</span><br><span class="line">5.x 之后 Kibana 等工具的主版本号进行了统一。</span><br><span class="line"></span><br><span class="line">Sql 语法支持</span><br><span class="line">2.x，5.x，6.x 都可以安装 Elasticsearch-sql 插件，使用熟悉的SQL语法查询 Elasticsearch。</span><br><span class="line">6.3.0 以后内置支持 SQL 模块，这个 SQL 模块是属于 X-Pack 的一部分。</span><br></pre></td></tr></table></figure><p>我选择目前最新的5.x版: <code>elasticsearch-5.6.16</code></p><h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><strong>注意: Elasticsearch5.0之后的版本至少需要Java 8</strong></p><p>下载对应版本安装包: <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">官方下载地址</a></p><p>下载后解压即可使用, 执行以下命令启动:</p><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><p><strong>Windows</strong> 进入elasticsearch安装目录/bin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双击 elasticsearch.bat</span><br></pre></td></tr></table></figure><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>CentOS版太大了, 我选择alpine版的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:5.6-alpine</span><br></pre></td></tr></table></figure><p><strong>启动容器</strong></p><p>在启动容器之前, 容器挂载的配置文件目录下面得要有配置文件，不然es是起不来的，比较方便的办法是，先不挂载启动es，然后用docker cp命令，把配置文件复制到宿主机挂载目录，然后再进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9200:9200 -p 9300:9300 --name=elasticsearch elasticsearch:5.6-alpine</span><br><span class="line"></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/config /data/software/elasticsearch/config </span><br><span class="line"></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/data /data/software/elasticsearch/data</span><br><span class="line"></span><br><span class="line">docker stop elasticsearch</span><br><span class="line"></span><br><span class="line">docker rm elasticsearch</span><br><span class="line"></span><br><span class="line">如果需要更改配置，可以直接修改config目录下的  elasticsearch.yml 文件，然后启动es</span><br><span class="line"></span><br><span class="line">docker run -d -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span>  -e ES_JAVA_OPTS=<span class="string">"-Xms512m -Xmx512m"</span> \</span><br><span class="line">-v /data/software/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/software/elasticsearch/config:/usr/share/elasticsearch/config \</span><br><span class="line">-v /data/software/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">--restart unless-stopped --name=elasticsearch elasticsearch:5.6-alpine</span><br></pre></td></tr></table></figure><p>检查es是否安装成功: 访问 <code>http://es_serverIp:9200</code></p><h2 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h2><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">下载地址</a></p><p>下载对应版本, 解压放入es安装目录中的plugin文件夹中, 重启es即可</p><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>Kibana 和 elasticsearch 同属于 elastic 公司。 Kibana是一个开源分析和可视化平台，旨在与Elasticsearch协同工作。使用Kibana搜索，可以查看和与存储在 Elasticsearch 索引中的数据进行交互。您可以轻松地执行高级数据分析，并在各种图表，表格和地图中可视化您的数据。</p><p><strong>Windows</strong></p><p>从<a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">官方下载地址</a>中下载与elasticsearch 版本对应 的Kibana, 解压即可使用:</p><ul><li>下载并解压缩 Kibana。</li><li>在编辑器中打开 <code>config/kibana.yml</code>。</li><li>设置 <code>elasticsearch.url</code> 为您的Elasticsearch实例，如本地：elasticsearch.url: “<a href="http://localhost:9200&quot;(与es装在同一机器可以不用设置)。" target="_blank" rel="noopener">http://localhost:9200&quot;(与es装在同一机器可以不用设置)。</a></li><li>运行bin/kibana.bat。</li><li>浏览器输入 <a href="http://localhost:5601。" target="_blank" rel="noopener">http://localhost:5601。</a></li></ul><p><strong><a href="https://www.elastic.co/guide/cn/kibana/current/docker.html" target="_blank" rel="noopener">CentOS</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  --link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。</span></span><br><span class="line">docker pull kibana:5.6.16</span><br><span class="line">docker run --init -d --name kibana --restart unless-stopped --link elasticsearch -p 5601:5601 kibana:5.6.16</span><br></pre></td></tr></table></figure><p>如果elasticsearch没有用docker运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ELASTICSEARCH_URL指定elasticsearch的ip</span></span><br><span class="line">docker run -it -d -e ELASTICSEARCH_URL=http://172.17.0.1:9200 -p 5601:5601 --name kibana kibana:5.6.16</span><br></pre></td></tr></table></figure><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题:"></a>碰到的问题:</h2><ul><li>不能以root身份启动elasticsearch, 否则会报错, 执行以下命令:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个非root用户, 比如创建新用户elasticsearch</span></span><br><span class="line">adduser elasticsearch</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">chown -R elasticsearch /elasticsearch安装目录</span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su elasticsearch</span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><ul><li>elasticsearch默认开启9200端口作为接收http请求, 如果想要开启9300端口:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑elasticsearch配置文件</span></span><br><span class="line">vi elasticsearch.yml</span><br><span class="line"><span class="comment"># 文件添加配置: </span></span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li><code>max virtual memory areas vm.max_map_count [65530] is too low</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件, 在最后添加一行  vm.max_map_count=655300</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令重新加载文件 </span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启elasticsearch: 先kill es进程再启动</span></span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><ul><li><code>max number of threads [1024] for user [elsearch] is too low, increase to at least [4096]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim /etc/security/limits.d/90-nproc.conf</span><br><span class="line"><span class="comment"># 将下面</span></span><br><span class="line">* soft nproc 1024</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line">* soft nproc 4096</span><br></pre></td></tr></table></figure><ul><li><code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vim /etc/security/limits.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最下面添加以下内容</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><ul><li>修改JVM参数(可选)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化内存分配2g</span></span><br><span class="line">-Xms2g</span><br><span class="line"><span class="comment"># 最大分配内存2g</span></span><br><span class="line">-Xmx2g</span><br></pre></td></tr></table></figure><ul><li>elasticsearch版本升级</li></ul><p>详情参考: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html" target="_blank" rel="noopener">官方文档</a></p><p>升级需要考虑到数据迁移, 不过也不难</p><p>安装好新版elasticsearch后, 修改新ES中的配置<code>elasticsearch.yml</code>文件,在里面添加一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个ip以逗号','隔开, 或者 127.0.10.*:9200</span></span><br><span class="line">reindex.remote.whitelist: oldhost:9200</span><br></pre></td></tr></table></figure><p>然后向新ES执行下面请求即可</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  "source": &#123;   // 获取来源的索引库</span><br><span class="line">    "remote": &#123;</span><br><span class="line">      "host": "http://oldhost:9200",</span><br><span class="line">      "username": "user",</span><br><span class="line">      "password": "password"</span><br><span class="line">    &#125;,</span><br><span class="line">    "index": "indexName",</span><br><span class="line">    "query": &#123;</span><br><span class="line">      "match": &#123;</span><br><span class="line">        "test": "data"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "dest": &#123;    // 生成的目标索引库</span><br><span class="line">    "index": "indexName"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本选择&quot;&gt;&lt;a href=&quot;#版本选择&quot; class=&quot;headerlink&quot; title=&quot;版本选择&quot;&gt;&lt;/a&gt;版本选择&lt;/h3&gt;&lt;p&gt;Elasticsearch 目前有三个常用的稳定的主版本：2.x，5.x，6.x, 目前最新是7.0.0&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门教程</title>
    <link href="https://huleski.github.io/2019/04/30/Elasticsearch%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://huleski.github.io/2019/04/30/Elasticsearch入门教程/</id>
    <published>2019-04-30T09:49:33.000Z</published>
    <updated>2019-07-09T07:17:01.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><p>Elasticsearch是一个高度可扩展的、开源的、基于 Lucene 的全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据，并支持多租户。</p><p>它使用Java开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><blockquote><p>集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。</p><p>集群由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入集群的话，则该节点只能是集群的一部分。<br>确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。</p></blockquote><h4 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点(Node)"></a>节点(Node)</h4><blockquote><p>一个运行的 ES 实例就是一个节点，节点存储数据并参与集群的索引和搜索功能。<br>就像集群一样，节点由名称标识，默认情况下，该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果不需要默认值，可以定义所需的任何节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中哪些服务器与 Elasticsearch 集群中的哪些节点相对应。</p><p>可以将节点配置为按集群名称加入特定集群。默认情况下，每个节点都设置为加入一个名为 cluster 的 elasticsearch 集群，这意味着如果您在网络上启动了许多节点并且假设它们可以相互发现 - 它们将自动形成并加入一个名为 elasticsearch 的集群。</p></blockquote><h4 id="索引（名词）"><a href="#索引（名词）" class="headerlink" title="索引（名词）"></a>索引（名词）</h4><blockquote><p>一个索引类似于传统关系数据库中的一个数据库 ，是一个存储关系型文档的地方，是ES对逻辑数据的逻辑存储，索引的结构是为快速有效的全文检索做准备。</p></blockquote><h4 id="索引（动词）"><a href="#索引（动词）" class="headerlink" title="索引（动词）"></a>索引（动词）</h4><blockquote><p>索引一个文档就是存储一个文档到一个索引（名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p></blockquote><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><blockquote><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted file)。</p></blockquote><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><blockquote><p>存储在ES上的主要实体叫文档</p></blockquote><h4 id="文档类型（在-6-0-0-及以上废弃）"><a href="#文档类型（在-6-0-0-及以上废弃）" class="headerlink" title="文档类型（在 6.0.0 及以上废弃）"></a>文档类型（在 6.0.0 及以上废弃）</h4><blockquote><p>在ES中，一个索引对象可以存储很多不同用途的对象。</p></blockquote><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><blockquote><p>存储有关字段的信息，每一个文档类型都有自己的映射。</p></blockquote><h4 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h4><blockquote><p>在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。</p><p>也许有一天你想把这些对象存储在数据库中。使用关系型数据库的行和列存储，这相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构–通常一个字段&gt;对应一列–而且又不得不在每次查询时重新构造对象。</p></blockquote><blockquote><p>Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档_。Elasticsearch 不仅存储文档，而且 _索引 每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤–而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p></blockquote><h4 id="分片-Shards"><a href="#分片-Shards" class="headerlink" title="分片(Shards)"></a>分片(Shards)</h4><blockquote><p>索引可能存储大量可能超过单个节点的硬件限制的数据。例如，占用1TB磁盘空间的十亿个文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独从单个节点提供搜索请求。</p><p>为了解决这个问题，Elasticsearch 提供了将索引细分为多个称为分片的功能。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。</p></blockquote><blockquote><p>设置分片的目的及原因主要是：</p><p>它允许您水平拆分/缩放内容量<br>它允许您跨分片（可能在多个节点上）分布和并行化操作，从而提高性能/吞吐量<br>分片的分布方式以及如何将其文档聚合回搜索请求的机制完全由 Elasticsearch 管理，对用户而言是透明的。</p><p>在可能随时发生故障的网络/云环境中，分片非常有用，建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch 允许您将索引的分片的一个或多个副本制作成所谓的副本分片或简称副本。</p></blockquote><h4 id="副本-Replicasedit"><a href="#副本-Replicasedit" class="headerlink" title="副本(Replicasedit)"></a>副本(Replicasedit)</h4><blockquote><p>副本，是对分片的复制。目的是为了当分片/节点发生故障时提供高可用性，它允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。</p><p>总而言之，每个索引可以拆分为多个分片。索引也可以复制为零次（表示没有副本）或更多次。复制之后，每个索引将具有主分片(从原始分片复制而来的)和复制分片(主分片的副本)。</p></blockquote><p><strong>副本是乘法，越多越浪费，但也越保险。分片是除法，分片越多，单分片数据就越少也越分散。</strong></p><p>一个对比图来类比传统关系型数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库   -&gt; Databases(库) -&gt; Tables(表)  -&gt; Rows(行)         -&gt; Columns(列)。</span><br><span class="line">Elasticsearch -&gt; Indeces(索引) -&gt; Types(类型) -&gt; Documents(文档) -&gt; Fields(属性)。</span><br></pre></td></tr></table></figure></p><h2 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h2><p>目前与 elasticsearch 交互主要有两种方式：Client API 和 RESTful API。</p><p>Client API方式：</p><p>Elasticsearch 为以下语言提供了官方客户端 –Groovy、JavaScript、.NET、 PHP、 Perl、 Python 和 Ruby–还有很多社区提供的客户端和插件，所有这些都可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" target="_blank" rel="noopener">Elasticsearch Clients</a> 中找到。</p><p>RESTful API with JSON over HTTP：</p><p>所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 curl 命令来和 Elasticsearch 交互。</p><p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span> -d <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>VERB</td><td>适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE</td></tr><tr><td>PROTOCOL</td><td>http 或者 https（如果你在 Elasticsearch 前面有一个https 代理）</td></tr><tr><td>HOST</td><td>Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点</td></tr><tr><td>PORT</td><td>运行 Elasticsearch HTTP 服务的端口号，默认是 9200</td></tr><tr><td>PATH</td><td>API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm</td></tr><tr><td>QUERY_STRING</td><td>任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</td></tr><tr><td>BODY</td><td>一个 JSON 格式的请求体 (如果请求需要的话)</td></tr></tbody></table><p><strong>常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/brand/_search?pretty=true'</span>         <span class="comment"># 查询索引数据</span></span><br><span class="line">curl -XPUT <span class="string">'localhost:9200/customer?pretty'</span>             <span class="comment"># 创建索引</span></span><br><span class="line">curl -XDELETE <span class="string">'localhost:9200/customer'</span>                 <span class="comment"># 删除索引</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/health?v'</span>                     <span class="comment"># 检测集群是否健康</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/nodes?v'</span>                      <span class="comment"># 获取集群节点</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/indices?v'</span>                    <span class="comment"># 列出所有索引</span></span><br><span class="line">curl -x GET <span class="string">'localhost:9200/index/_mapping'</span>             <span class="comment"># 查询指定索引的映射</span></span><br><span class="line">curl -X GET <span class="string">'localhost:9200/_cluster/health?pretty'</span>     <span class="comment"># 查看分片状态</span></span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ol><li>创建第一个简单索引</li></ol><p>创建一个 NBA 球队的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT nba</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>: 3,   </span><br><span class="line">    <span class="string">"number_of_replicas"</span>: 1 </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"mappings"</span>:&#123;</span><br><span class="line">    <span class="string">"nba"</span>:&#123;</span><br><span class="line">      <span class="string">"properties"</span>:&#123;</span><br><span class="line">        <span class="string">"name_cn"</span>:&#123; </span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"name_en"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"gymnasium"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"topStar"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"championship"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"integer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"date"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"date"</span>,</span><br><span class="line">          <span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss|| yyy-MM-dd||epoch_millis"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>字段名称</th><th>字段说明</th></tr></thead><tbody><tr><td>nba</td><td>索引</td></tr><tr><td>number_of_shards</td><td>分片数</td></tr><tr><td>number_of_replicas</td><td>副本数</td></tr><tr><td>name_cn</td><td>球队中文名</td></tr><tr><td>name_en</td><td>球队英文名</td></tr><tr><td>gymnasium</td><td>球馆名称</td></tr><tr><td>championship</td><td>总冠军次数</td></tr><tr><td>topStar</td><td>当家球星</td></tr><tr><td>date</td><td>加入NBA年份</td></tr></tbody></table><p>创建成功则返回信息:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"acknowledged"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"shards_acknowledged"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"index"</span>: <span class="string">"nba"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>新增索引数据</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">PUT /nba/nba/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"San Antonio Spurs SAS"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"圣安东尼安马刺"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"AT&amp;T中心球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"蒂姆·邓肯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1995-04-12"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Los Angeles Lakers"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"洛杉矶湖人"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"斯台普斯中心球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"科比·布莱恩特"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1947-05-12"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Golden State Warriors"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"金州勇士队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"甲骨文球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1949-06-13"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Miami Heat"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"迈阿密热火队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"美国航空球场"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"勒布朗·詹姆斯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1988-06-13"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/5</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Cleveland Cavaliers"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"克利夫兰骑士队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"速贷球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"勒布朗·詹姆斯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1970-06-13"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>查询全部球队的信息</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应结果:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Los Angeles Lakers"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"洛杉矶湖人"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"斯台普斯中心球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"科比·布莱恩特"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1947-05-12"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"San Antonio Spurs SAS"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"圣安东尼安马刺"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"AT&amp;T中心球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"蒂姆·邓肯"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1995-04-12"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"金州勇士队"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"甲骨文球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1949-06-13"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应的数据结果分为两部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">----------------first part--------------------</span><br><span class="line">  "took": 0,</span><br><span class="line">  "timed_out": false,</span><br><span class="line">  "_shards": &#123;</span><br><span class="line">    "total": 3,</span><br><span class="line">    "successful": 3,</span><br><span class="line">    "skipped": 0,</span><br><span class="line">    "failed": 0</span><br><span class="line">  &#125;,</span><br><span class="line">---------------second part---------------------</span><br><span class="line">  "hits": &#123;</span><br><span class="line">    "total": 0,</span><br><span class="line">    "max_score": null,</span><br><span class="line">    "hits": []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分为：分片副本信息，第二部分 hits 包装的为查询的数据集。</p><ol start="4"><li>查询英文名称为：”Golden State Warriors” 的球队信息</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可得到的查询结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1.9646256</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1.9646256</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"金州勇士队"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"甲骨文球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1949-06-13"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>过滤查询 Filter</li></ol><p>我们让搜索变的复杂一些。我们想要找到当家球星是勒布朗·詹姆斯，但是我们只想得到总冠军多于1次的球队。我们的语句将做一些改变用来添加过滤器(filter),它允许我们有效的执行一个结构化搜索</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">          <span class="attr">"championship"</span>: &#123;</span><br><span class="line">            <span class="attr">"gt"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"勒布朗·詹姆斯"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现每次查询，查询结果里面都有一个 _score字段，一般Elasticsearch根据相关评分排序，相关评分是根据文档与语句的匹配度来得出， _score值越高说明匹配度越高。</p><p><strong>查询命令</strong></p><ol><li>query_string语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>分页查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "from" : 1,</span></span><br><span class="line"><span class="string">    "size" : 1,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>增加version值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "from" : 1,</span></span><br><span class="line"><span class="string">    "size" : 1,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>限制得分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="5"><li>选择要返回的字段</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "fields" : ["brandName","spuName"],</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="6"><li>选择要返回的字段</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "fields" : ["brandName","spuName"],</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot与Elasticsearch集成"><a href="#SpringBoot与Elasticsearch集成" class="headerlink" title="SpringBoot与Elasticsearch集成"></a>SpringBoot与Elasticsearch集成</h2><ol><li>pom文件中添加添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 解决es no jna warning--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>application.yml添加配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    data:</span></span><br><span class="line"><span class="attr">        elasticsearch:</span></span><br><span class="line"><span class="attr">            cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：elasticsearch jar版本要与安装的服务版本相容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch简介&quot;&gt;&lt;a href=&quot;#Elasticsearch简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch简介&quot;&gt;&lt;/a&gt;Elasticsearch简介&lt;/h2&gt;&lt;p&gt;Elasticsearch是一个高度
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://huleski.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装RabbitMQ</title>
    <link href="https://huleski.github.io/2019/04/22/CentOS7%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>https://huleski.github.io/2019/04/22/CentOS7安装RabbitMQ/</id>
    <published>2019-04-22T01:26:36.000Z</published>
    <updated>2019-08-29T00:32:38.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装ErLang"><a href="#安装ErLang" class="headerlink" title="安装ErLang"></a>安装ErLang</h2><p>rabbitmq依赖于erlang, 因此要<strong>先安装erlang</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget  http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span><br><span class="line">rpm -Uvh erlang-solutions-1.0-1.noarch.rpm</span><br><span class="line">yum install erlang</span><br></pre></td></tr></table></figure><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.14/rabbitmq-server-3.7.14-1.el7.noarch.rpm</span><br><span class="line">yum -y install rabbitmq-server-3.7.14-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server             <span class="comment"># 启动RabbitMQ</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server            <span class="comment"># 开机自启动RabbitMQ</span></span><br><span class="line">systemctl status rabbitmq-server            <span class="comment"># 查看状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他启动方式</span></span><br><span class="line">rabbitmq-server                             <span class="comment"># 启动 RabbitMQ服务</span></span><br><span class="line">rabbitmqctl stop                            <span class="comment"># 停止RabbitMQ服务</span></span><br><span class="line">rabbitmqctl start_app                       <span class="comment"># 启动application</span></span><br><span class="line">rabbitmqctl stop_app                        <span class="comment"># 停止application</span></span><br><span class="line">rabbitmq-server -detached                   <span class="comment"># 后台启动 RabbitMQ服务</span></span><br></pre></td></tr></table></figure><h2 id="访问web控制台"><a href="#访问web控制台" class="headerlink" title="访问web控制台"></a>访问web控制台</h2><p>初始帐号和密码都为：guest, 但是只能本地登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq-management                 <span class="comment"># 启动RabbitMQ Web管理控制台</span></span><br><span class="line">chown -R rabbitmq:rabbitmq /var/lib/rabbitmq/               <span class="comment"># 将RabbitMQ文件的所有权提供给RabbitMQ用户</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user admin 123456                           <span class="comment"># 为RabbitMQ Web管理控制台创建管理用户</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator               <span class="comment"># 为admin设置管理员角色</span></span><br><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span>       <span class="comment"># 为admin设置默认vhost（“/”）配置、写、读全部权限</span></span><br></pre></td></tr></table></figure><p>访问: <code>http://RabbitMQ_IP:15672/</code> 就能看到RabbitMQ管理页面</p><h2 id="角色说明"><a href="#角色说明" class="headerlink" title="角色说明"></a>角色说明</h2><ul><li><p>超级管理员(administrator)</p><p>  可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p></li><li><p>监控者(monitoring)</p><p>  可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p></li><li><p>策略制定者(policymaker)</p><p>  可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p></li><li><p>普通管理者(management)</p><p>  仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p></li><li><p>其他</p><p>  无法登陆管理控制台，通常就是普通的生产者和消费者。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装ErLang&quot;&gt;&lt;a href=&quot;#安装ErLang&quot; class=&quot;headerlink&quot; title=&quot;安装ErLang&quot;&gt;&lt;/a&gt;安装ErLang&lt;/h2&gt;&lt;p&gt;rabbitmq依赖于erlang, 因此要&lt;strong&gt;先安装erlang&lt;/stron
      
    
    </summary>
    
      <category term="CentOS7" scheme="https://huleski.github.io/categories/CentOS7/"/>
    
    
      <category term="CentOS7" scheme="https://huleski.github.io/tags/CentOS7/"/>
    
      <category term="RabbitMQ" scheme="https://huleski.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门教程</title>
    <link href="https://huleski.github.io/2019/04/19/RabbitMQ%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://huleski.github.io/2019/04/19/RabbitMQ入门教程/</id>
    <published>2019-04-19T02:25:59.000Z</published>
    <updated>2019-07-09T07:36:45.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h2><p>RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。</p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>MQ 全称为Message Queue, 消息队列。是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><p>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的要求。<br>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><h2 id="RabbitMQ-应用场景"><a href="#RabbitMQ-应用场景" class="headerlink" title="RabbitMQ 应用场景"></a>RabbitMQ 应用场景</h2><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：</p><blockquote><p>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？</p><p>2）如何降低发送者和接收者的耦合度？</p><p>3）如何让Priority高的接收者先接到数据？</p><p>4）如何做到load balance？有效均衡接收者的负载？</p><p>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</p><p>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</p><p>7）如何保证接收者接收到了完整，正确的数据？</p></blockquote><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-b22270d646a5aeef.jpg" alt="Rabbitmq"></p><h2 id="RabbitMQ使用流程"><a href="#RabbitMQ使用流程" class="headerlink" title="RabbitMQ使用流程"></a>RabbitMQ使用流程</h2><p>AMQP模型中，消息在producer中产生，发送到MQ的exchange上，exchange根据配置的路由方式发到相应的Queue上，Queue又将消息发送给consumer，消息从queue到consumer有push和pull两种方式。 消息队列的使用过程大概如下：</p><ol><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ol><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。 exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。</p><p><strong>RabbitMQ的安装</strong> : 查看下一篇文章</p><h2 id="Java入门实例-Helloworld"><a href="#Java入门实例-Helloworld" class="headerlink" title="Java入门实例(Helloworld)"></a>Java入门实例(Helloworld)</h2><p>一个producer发送消息，一个接收者接收消息，并在控制台打印出来。</p><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-71798beda1e4057.jpg" alt="mq消费过程"></p><p><strong>Java客户端配置</strong></p><p>加入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>发送端</strong>：Send.java 连接到RabbitMQ（此时服务需要启动），发送一条数据，然后退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"helloMQ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> java.io.IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建连接连接到MabbitMQ</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置MabbitMQ所在主机ip或者主机名</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//指定一个队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//发送的消息</span></span><br><span class="line">        String message = <span class="string">"hello world!"</span>;</span><br><span class="line">        <span class="comment">//往队列中发出一条消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是队列只会在它不存在的时候创建，多次声明并不会重复创建。信息的内容是字节数组，也就意味着你可以传递任何数据。</p><p><strong>接收端</strong>：Recv.java 不断等待服务器推送消息，然后在控制台输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"helloMQ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 打开连接和创建频道，与发送端一样</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ工作队列-Work-Queues（Java实例）"><a href="#RabbitMQ工作队列-Work-Queues（Java实例）" class="headerlink" title="RabbitMQ工作队列-Work Queues（Java实例）"></a>RabbitMQ工作队列-Work Queues（Java实例）</h2><p>创建一个工作队列用来在工作者（consumer）间分发耗时任务。</p><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-1153d8d6c2a8d9a3.jpg" alt="RabbitMQ工作队列"></p><p>工作队列的主要任务是：避免立刻执行资源密集型任务，然后必须等待其完成。相反地，我们进行任务调度：我们把任务封装为消息发送给队列。工作进行在后台运行并不断的从队列中取出任务然后执行。当你运行了多个工作进程时，任务队列中的任务将会被工作进程共享执行。</p><p>我们使用Thread.sleep来模拟耗时的任务, 然后启动两个work, 可以发现<code>消费时间变短</code>了</p><p><strong>发送端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        String message = String.valueOf(System.currentTimeMillis());</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">final</span> Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep( <span class="number">5000</span>);    <span class="comment">// 执行耗时操作</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">" [x] Done"</span> + message);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用任务队列的好处是能够很容易的并行工作。如果我们积压了很多工作，我们仅仅通过增加更多的工作者就可以解决问题，使系统的伸缩性更加容易。</p><p><strong>消息确认</strong><br>执行一个任务需要花费几秒钟。你可能会担心当一个工作者在执行任务时发生中断。我们上面的代码，一旦RabbItMQ交付了一个信息给消费者，会马上从内存中移除这个信息。在这种情况下，如果杀死正在执行任务的某个工作者，我们会丢失它正在处理的信息。我们也会丢失已经转发给这个工作者且它还未执行的消息。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span> ; <span class="comment">//打开消息应答机制  </span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, ack, consumer);  </span><br><span class="line"><span class="comment">//另外需要在每次处理完成一个消息后，手动发送一次应答。  </span></span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><strong>消息的持久性</strong></p><p>虽然消费者被杀死，消息也不会被丢失。但是如果此时RabbitMQ服务被停止，我们的消息仍然会丢失。<br>当RabbitMQ退出或者异常退出，将会丢失所有的队列和信息，除非你告诉它不要丢失。我们需要做两件事来确保信息不会被丢失：我们需要给所有的队列和消息设置持久化的标志。</p><p>第一， 我们需要确认RabbitMQ永远不会丢失我们的队列。为了这样，我们需要声明它为持久化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"task_queue"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注：RabbitMQ不允许使用不同的参数重新定义一个队列，所以已经存在的队列，我们无法修改其属性。</p><p>第二， 我们需要标识我们的信息为持久化的。通过设置MessageProperties（implements BasicProperties）值为<code>PERSISTENT_TEXT_PLAIN</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"task_queue"</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br></pre></td></tr></table></figure><p>现在你可以执行一个发送消息的程序，然后关闭服务，再重新启动服务，运行消费者程序测试。</p><p><strong>公平的分配</strong></p><p>或许会发现，目前的消息转发机制（Round-robin）并非是我们想要的。例如，这样一种情况，对于两个消费者，有一系列的任务，奇数任务特别耗时，而偶数任务却很轻松，这样造成一个消费者一直繁忙，另一个消费者却很快执行完任务后等待。<br>造成这样的原因是因为RabbitMQ仅仅是当消息到达队列进行转发消息。并不在乎有多少任务消费者并未传递一个应答给RabbitMQ。仅仅盲目转发所有的奇数给一个消费者，偶数给另一个消费者。</p><p>为了解决这样的问题，我们可以使用basicQos方法，传递参数为prefetchCount = 1。这样告诉RabbitMQ不要在同一时间给一个消费者超过一条消息。换句话说，只有在消费者空闲的时候会发送下一条信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;  </span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h2 id="Exchange-的几种模式"><a href="#Exchange-的几种模式" class="headerlink" title="Exchange 的几种模式"></a>Exchange 的几种模式</h2><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种，分别有以下一些属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name：名称</span><br><span class="line">Durability：持久化标志，如果为true，则表明此exchange是持久化的。</span><br><span class="line">Auto-delete：删除标志，当所有队列在完成使用此exchange时，是否删除</span><br></pre></td></tr></table></figure><p><strong>1、fanout类型</strong></p><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到fanout Exchange的消息都会被转发到与该Exchange 绑定(Binding)的所有Queue上。</p><p>Fanout Exchange  不需要处理RouteKey 。只需要简单的将队列绑定到exchange 上。这样发送到exchange的消息都会被转发到与该交换机绑定的所有队列上。类似子网广播，每台子网内的主机都获得了一份复制的消息。所以，Fanout Exchange 转发消息是最快的。</p><p><strong>2、direct类型</strong></p><p>direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</p><p>direct Exchange是RabbitMQ Broker的<code>默认Exchange</code>，它有一个特别的属性对一些简单的应用来说是非常有用的，在使用这个类型的Exchange时，可以不必指定routing key的名字，在此类型下创建的Queue有一个默认的routing key，这个routing key一般同Queue同名。</p><p>direct模式,可以使用rabbitMQ自带的Exchange：default Exchange 。所以不需要将Exchange进行任何绑定(binding)操作 。消息传递时，RouteKey必须完全匹配，才会被队列接收，否则该消息会被抛弃。</p><p><strong>3、topic类型</strong></p><p>topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p><blockquote><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</p><p>binding key与routing key一样也是句点号“. ”分隔的字符串</p><p>binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</p></blockquote><p>所有发送到Topic Exchange的消息被转发到所有关心RouteKey中指定Topic的Queue上，Exchange 将RouteKey 和某Topic 进行模糊匹配。此时队列需要绑定一个Topic。可以使用通配符进行模糊匹配，符号“#”匹配一个或多个词，符号“”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.” 只会匹配到“log.error”。</p><p><strong>4、headers类型</strong></p><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</p><p>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ-简介&quot;&gt;&lt;a href=&quot;#RabbitMQ-简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 简介&quot;&gt;&lt;/a&gt;RabbitMQ 简介&lt;/h2&gt;&lt;p&gt;RabbitMQ是一个在AMQP（Advanced Message 
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://huleski.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://huleski.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>消息队列之JMS和AMQP的关系</title>
    <link href="https://huleski.github.io/2019/04/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BJMS%E5%92%8CAMQP%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://huleski.github.io/2019/04/19/消息队列之JMS和AMQP的关系/</id>
    <published>2019-04-19T01:41:16.000Z</published>
    <updated>2019-07-09T07:41:09.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>通常而言提到JMS（Java MessageService）实际上是指JMS API。JMS是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive等。JMS已经成为Java Enterprise Edition的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了JMS的服务进行通信，进行相关的操作。</p><p>JMS通常包含如下一些角色：<br>Elements    |   Notes<br>———– | ——–<br>JMS provider    |   实现了JMS接口的消息中间件，如ActiveMQ<br>JMS client    |   生产或者消费消息的应用<br>JMS producer/publisher    |   JMS消息生产者<br>JMS consumer/subscriber    |   JMS消息消费者<br>JMS message    |    消息，在各个JMS client传输的对象；<br>JMS queue    |   Provider存放等待被消费的消息的地方<br>JMS topic    |   一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。</p><p> JMS提供了两种消息模型，peer-2-peer(点对点)以及publish-subscribe（发布订阅）模型。当采用点对点模型时，消息将发送到一个队列，该队列的消息只能被一个消费者消费。而采用发布订阅模型时，消息可以被多个消费者消费。在发布订阅模型中，生产者和消费者完全独立，不需要感知对方的存在。</p><p>消息如何从producer端达到consumer端由message-routing来决定。在JMS中，消息路由非常简单，由producer和consumer链接到同一个queue（p2p）或者topic（pub/sub）来实现消息的路由。JMSconsumer同时支持message selector（消息选择器），通过消息选择器，consumer可以只消费那些通过了selector筛选的消息。在JMS兄中，消息路由机制的图示如下：</p><p><img src="http://pubgmjp23.bkt.clouddn.com/20140410230348859.png" alt="消息路由"></p><p>常见的消息队列，大部分都实现了JMS API，可以担任JMS provider的角色，如ActiveMQ，Redis以及RabbitMQ等。</p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。意味着我们可以使用Java的AMQP provider，同时使用一个python的producer加一个rubby的consumer。从这一点看，AQMP可以用http来进行类比，不关心实现的语言，只要大家都按照相应的数据格式去发送报文请求，不同语言的client均可以和不同语言的server链接。</p><p>在AMQP中，消息路由（messagerouting）和JMS存在一些差别，在AMQP中增加了Exchange和binding的角色。producer将消息发送给Exchange，binding决定Exchange的消息应该发送到那个queue，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。AMQP的routing scheme图示过程如下：</p><p><img src="http://pubgmjp23.bkt.clouddn.com/20140410230404281.png" alt="AMQP"></p><p>目前AMQP逐渐成为消息队列的一个标准协议，当前比较流行的rabbitmq、stormmq都使用了AMQP实现。</p><p>JMS和AMQP的各项对比如下：</p><table><thead><tr><th>信息</th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java api</td><td>Wire-protocol</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>Model</td><td>提供两种消息模型：<br>（1）、Peer-2-Peer<br>（2）、Pub/sub</td><td>提供了五种消息模型：<br>（1）、direct exchange<br>（2）、fanout exchange<br>（3）、topic change<br>（4）、headers exchange<br>（5）、system exchange<br>本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td>支持消息类型</td><td>多种消息类型：<br>TextMessage<br>MapMessage<br>BytesMessage<br>StreamMessage<br>ObjectMessage<br>Message （只有消息头和属性）</td><td>byte[]<br>当实际应用时，有复杂的消息，可以将消息序列化后发送。</td></tr><tr><td>综合评价</td><td>JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差；</td><td>AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。</td></tr></tbody></table><p><a href="https://blog.csdn.net/hpttlook/article/details/23391967" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JMS&quot;&gt;&lt;a href=&quot;#JMS&quot; class=&quot;headerlink&quot; title=&quot;JMS&quot;&gt;&lt;/a&gt;JMS&lt;/h2&gt;&lt;p&gt;通常而言提到JMS（Java MessageService）实际上是指JMS API。JMS是由Sun公司早期提出的消息标准，旨在为
      
    
    </summary>
    
      <category term="消息队列" scheme="https://huleski.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="https://huleski.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装JDK1.8</title>
    <link href="https://huleski.github.io/2019/04/17/CentOS7%E5%AE%89%E8%A3%85JDK1-8/"/>
    <id>https://huleski.github.io/2019/04/17/CentOS7安装JDK1-8/</id>
    <published>2019-04-17T02:07:07.000Z</published>
    <updated>2019-04-17T02:33:33.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看已安装的jdk并卸载"><a href="#查看已安装的jdk并卸载" class="headerlink" title="查看已安装的jdk并卸载"></a>查看已安装的jdk并卸载</h2><p>查询jdk ( 新装的centos会默认安装openjre )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis java</span><br><span class="line"><span class="built_in">which</span> java （java执行路径）</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>确定JDK的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure><p>可能的结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br></pre></td></tr></table></figure><p>卸载jdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64  </span><br><span class="line">yum -y remove java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.htm" target="_blank" rel="noopener">下载地址</a></p><p>将下载好的文件<code>jdk-8u191-linux-x64.tar.gz</code>放在 <code>/data</code> 目录下, 解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>解压成功后，则可以看到jdk1.8.0_191文件夹</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在配置文件末尾添加一下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/data/jdk1.8.0_191</span><br><span class="line">JRE_HOME=/data/jdk1.8.0_191/jre</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><p>保存退出, 是配置文件立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profie</span><br></pre></td></tr></table></figure><p>查看java是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看已安装的jdk并卸载&quot;&gt;&lt;a href=&quot;#查看已安装的jdk并卸载&quot; class=&quot;headerlink&quot; title=&quot;查看已安装的jdk并卸载&quot;&gt;&lt;/a&gt;查看已安装的jdk并卸载&lt;/h2&gt;&lt;p&gt;查询jdk ( 新装的centos会默认安装openjre 
      
    
    </summary>
    
      <category term="CentOS7" scheme="https://huleski.github.io/categories/CentOS7/"/>
    
    
      <category term="CentOS7" scheme="https://huleski.github.io/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机GC详解</title>
    <link href="https://huleski.github.io/2019/04/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://huleski.github.io/2019/04/13/Java虚拟机GC详解/</id>
    <published>2019-04-13T10:39:00.000Z</published>
    <updated>2019-04-22T01:24:20.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-GC的定义和价值"><a href="#1-GC的定义和价值" class="headerlink" title="1. GC的定义和价值"></a>1. GC的定义和价值</h2><p>​    在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止人为的内存泄露。</p><p>　    Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代 码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。</p><p>​    概括地说，该机制对 JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><h2 id="2-思考GC的运行原理"><a href="#2-思考GC的运行原理" class="headerlink" title="2. 思考GC的运行原理"></a>2. 思考GC的运行原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一步：确认那些对象需要回收</span><br><span class="line">第二步：使用什么方法回收</span><br></pre></td></tr></table></figure><h2 id="3-确认哪些对象需要回收"><a href="#3-确认哪些对象需要回收" class="headerlink" title="3. 确认哪些对象需要回收"></a>3. 确认哪些对象需要回收</h2><p>常见的算法有2种：引用计数算法和根搜索算法。</p><ul><li>引用计算法无法解决循环引用问题，java不采用，采用了根搜索算法。</li></ul><h4 id="3-1-引用计数法"><a href="#3-1-引用计数法" class="headerlink" title="3-1 引用计数法"></a>3-1 引用计数法</h4><h6 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3-1-1 概念"></a>3-1-1 概念</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</span><br></pre></td></tr></table></figure><h5 id="3-1-2-特点"><a href="#3-1-2-特点" class="headerlink" title="3-1-2 特点"></a>3-1-2 特点</h5><p>引用计数算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。<br>它很难解决对象之间相互循环引用的问题,对于循环引用的对象无法进行回收</p><ul><li>由于循环引用的计数器都不为0，但是他们对于根对象都已经不可达了，但是无法释放。</li></ul><h4 id="3-2-根搜索算法"><a href="#3-2-根搜索算法" class="headerlink" title="3-2 根搜索算法"></a>3-2 根搜索算法</h4><h4 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3-2-1 概念"></a>3-2-1 概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于引用计数算法的缺陷，所以JVM一般会采用一种新的算法，叫做根搜索算法。它的处理方式就是，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</span><br></pre></td></tr></table></figure><p><img src="/images/jvm_gc/jvm_gc1.webp" alt="Logo"></p><h4 id="3-2-2-特点"><a href="#3-2-2-特点" class="headerlink" title="3-2-2 特点"></a>3-2-2 特点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如上图所示, 由于GC roots到灰色对象部分不可达，所以最终灰色对象部分还是会被当做GC的对象，上图若是采用引用计数法，则灰色对象部分都不会被回收。</span><br></pre></td></tr></table></figure><p>3-2-3 可达性的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 来历</span><br><span class="line">* 我们刚刚提到，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</span><br><span class="line">* 我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调从根节点开始，对所有可达对象做一次标记，那什么叫做可达呢？</span><br><span class="line"></span><br><span class="line">2. 讲解</span><br><span class="line">* 这里解释如下：可达性分析：从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连（用图论的概念来讲，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</span><br><span class="line"></span><br><span class="line">3. jvm常见的根(GC roots)对象</span><br><span class="line">a. 栈（栈帧中的本地变量表）中引用的对象。</span><br><span class="line">b. 方法区中的静态成员。</span><br><span class="line">c. 方法区中的常量引用的对象（全局变量</span><br><span class="line">d. 方法栈中JNI（一般说的Native方法）引用的对象。</span><br><span class="line"></span><br><span class="line">**注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</span><br></pre></td></tr></table></figure><h2 id="4-基础的GC回收算法"><a href="#4-基础的GC回收算法" class="headerlink" title="4. 基础的GC回收算法"></a>4. 基础的GC回收算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。</span><br></pre></td></tr></table></figure><h4 id="4-1-最基础：标记-清除算法"><a href="#4-1-最基础：标记-清除算法" class="headerlink" title="4-1  最基础：标记/清除算法"></a>4-1  最基础：标记/清除算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 介绍</span><br><span class="line">标记/清除算法是几种GC算法中最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</span><br><span class="line"></span><br><span class="line">2. 原理</span><br><span class="line">* 标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</span><br><span class="line"></span><br><span class="line">* 标记阶段：标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象；</span><br><span class="line"></span><br><span class="line">* 清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收。</span><br><span class="line"></span><br><span class="line">3. 具体的算法过程</span><br><span class="line">* 在标记阶段，从对象GC Root 1可以访问到B对象，从B对象又可以访问到E对象，因此从GC Root 1到B、E都是可达的，同理，对象F、G、J、K都是可达对象；到了清除阶段，所有不可达对象都会被回收。</span><br><span class="line"></span><br><span class="line">* 在垃圾收集器进行GC时，必须停止所有Java执行线程（也称&quot;STW, Stop The World&quot;），原因是在标记阶段进行可达性分析时，不可以出现分析过程中对象引用关系还在不断变化的情况，否则的话可达性分析结果的准确性就无法得到保证。在等待标记清除结束后，应用线程才会恢复运行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存在的缺陷:</span><br><span class="line">1、效率问题。标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。</span><br><span class="line">2、空间问题。标记清除之后会产生大量不连续的内存碎片（从上图可以看出），内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</span><br><span class="line"></span><br><span class="line">* 内存碎片的影响</span><br></pre></td></tr></table></figure><h4 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4-2 复制算法"></a>4-2 复制算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原理</span><br><span class="line">* 复制算法为了解决效率问题，复制算法出现了。复制算法的原理是：将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉。</span><br><span class="line"></span><br><span class="line">2. 具体的算法过程</span><br><span class="line">* 复制算法每次都是对整个半区进行内存回收，这样就减少了标记对象遍历的时间，在清除使用区域对象时，不用进行遍历，直接清空整个区域内存，而且在将存活对象复制到保留区域时也是按地址顺序存储的，这样就解决了内存碎片的问题，在分配对象内存时不用考虑内存碎片等复杂问题，只需要按顺序分配内存即可。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 优缺点</span><br><span class="line">* 复制算法简单高效，优化了标记/清除算法的效率低、内存碎片多的问题。</span><br><span class="line">* 缺点也很明显：</span><br><span class="line">a. 将内存缩小为原来的一半，浪费了一半的内存空间，代价太高</span><br><span class="line">b. 如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍，耗费的时间代价也是不可忽视的。</span><br></pre></td></tr></table></figure><h4 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4-3 标记/整理算法"></a>4-3 标记/整理算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原理</span><br><span class="line">    从名字上看，这种算法与标记/清除算法很像，事实上，标记/整理算法的标记过程任然与标记/清除算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。</span><br><span class="line"></span><br><span class="line">2. 算法分析</span><br><span class="line">    回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。这样一来，当我们给新对象分配内存时，jvm只需要持有内存的起始地址即可。标记/整理算法不仅弥补了标记/清除算法存在内存碎片的问题，也消除了复制算法内存减半的高额代价，可谓一举两得。但任何算法都有缺点，就像人无完人，标记/整理算法的缺点就是效率也不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。</span><br></pre></td></tr></table></figure><h4 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4-4 总结"></a>4-4 总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 弄清了以上三种算法的原理，下面我们来从几个方面对这几种算法做一个简单排行。</span><br><span class="line"></span><br><span class="line">效率：复制算法 &gt; 标记/整理算法 &gt; 标记/清除算法（标记/清除算法有内存碎片问题，给大对象分配内存时可能会触发新一轮垃圾回收）</span><br><span class="line">内存整齐率：复制算法 = 标记/整理算法 &gt; 标记/清除算法</span><br><span class="line">内存利用率：标记/整理算法 = 标记/清除算法 &gt; 复制算法</span><br><span class="line"></span><br><span class="line">从上面简单的评估可以看出，标记/清除算法已经比较落后了，但是吃水不忘挖井人，它是后面几种算法的前辈、是基础，在某些场景下它也有用武之地。</span><br></pre></td></tr></table></figure><h2 id="5-JVM采用的GC回收算法：分代回收算法"><a href="#5-JVM采用的GC回收算法：分代回收算法" class="headerlink" title="5.  JVM采用的GC回收算法：分代回收算法"></a>5.  JVM采用的GC回收算法：分代回收算法</h2><h4 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5-1 概念"></a>5-1 概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 引言</span><br><span class="line">* 通过上面的分析，每种算法都有各自的特点，没有完美的解决方案。所以，JVM虚拟机，根据自身的特点，设计了一个特别的GC回收机制： 分代回收算法。</span><br><span class="line"></span><br><span class="line">2. 分代回收算法概念</span><br><span class="line">* 根据对象的存活周期的不同，将内存划分为几块儿。</span><br><span class="line">* Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。</span><br></pre></td></tr></table></figure><h4 id="5-2-原理"><a href="#5-2-原理" class="headerlink" title="5-2 原理"></a>5-2 原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分代回收算法原理</span><br><span class="line">a. 少量对象存活，适合复制算法：</span><br><span class="line">* 在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。</span><br><span class="line"></span><br><span class="line">b. 大量对象存活，适合用标记-清理/标记-整理：</span><br><span class="line">* 在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。</span><br></pre></td></tr></table></figure><h4 id="5-3-新生代和老年代对象的来历"><a href="#5-3-新生代和老年代对象的来历" class="headerlink" title="5-3 新生代和老年代对象的来历"></a>5-3 新生代和老年代对象的来历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a. 所有第一次分配的对象，都是新生代。</span><br><span class="line">b. 新生代的内存满后，启动GC，大概98%的对象会被回收，2%的对象，会存活下来。每经历一次GC，对象的年龄增长1岁。</span><br><span class="line">c. 当年龄达到阀值（默认是15，可设定），即经历了15次GC，仍然活着，就从新生代转移到老年代。</span><br><span class="line"></span><br><span class="line">d. 老年代还有来历特别的对象：新生代进行垃圾回收时，某个对象特别大，可能无需等到15岁，就直接进入老年代</span><br></pre></td></tr></table></figure><h4 id="5-3-新生代的回收策略"><a href="#5-3-新生代的回收策略" class="headerlink" title="5-3 新生代的回收策略"></a>5-3 新生代的回收策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 新生代的特点</span><br><span class="line">* 新生代中的对象几乎都是“朝生夕死”的（达到98%，即98%的对象活不过1岁）</span><br><span class="line"></span><br><span class="line">2. 选择复制算法的原因分析</span><br><span class="line">* 复制算法的效率最高，但是浪费50%的内存。</span><br><span class="line">* 但是新生代的对象存活率低，所以并不需要按照1：1的比例来划分内存空间</span><br><span class="line">* 而是将内存分为一块较大的Eden空间和两块较小的Survivor1空间、Survivor2空间，三者的比例为8：1：1。</span><br><span class="line"></span><br><span class="line">3. 算法的实现</span><br><span class="line">* 将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。</span><br><span class="line">* 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</span><br><span class="line">* 默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</span><br><span class="line">* 98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</span><br></pre></td></tr></table></figure><h4 id="5-4-GC分类"><a href="#5-4-GC分类" class="headerlink" title="5-4 GC分类"></a>5-4 GC分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Minor GC：只有新生代进行GC，发生频繁，但是，STW(stop the world)的时间短。</span><br><span class="line">Major GC: 年长代进行GC, 因年长代空间比新生代大，故运行次数少，其一般采用“标记-清理”/“标记-整理”，STW的时间长。</span><br><span class="line">FULL GC: 新生代和年老代，都进行GC操作。所需时间最长，STW最长。</span><br></pre></td></tr></table></figure><h4 id="5-5-STW-Stop-The-World"><a href="#5-5-STW-Stop-The-World" class="headerlink" title="5-5 STW(Stop-The-World)"></a>5-5 STW(Stop-The-World)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 概念</span><br><span class="line">* Java中一种全局暂停的现象。全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互多半情况下是由于GC引起。</span><br><span class="line"></span><br><span class="line">2. GC引起STW的原因</span><br><span class="line">* 打个比方：类比在聚会，突然GC要过来打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。况且，如果没有全局停顿，会给GC线程造成很大的负担，GC算法的难度也会增加，GC很难去判断哪些是垃圾。</span><br><span class="line"></span><br><span class="line">3. 危害</span><br><span class="line">* 长时间服务停止，没有响应</span><br></pre></td></tr></table></figure><h2 id="JVM-GC-垃圾回收器类型"><a href="#JVM-GC-垃圾回收器类型" class="headerlink" title="JVM GC 垃圾回收器类型"></a>JVM GC 垃圾回收器类型</h2><p>JVM的垃圾回收器大致分为四种类型：<br><img src="/images/jvm_gc/jvm_gc2.jpg" alt="jvm类型"></p><p><strong>1、串行垃圾回收器  Serial Garbage Collector</strong></p><p>串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作。<br>串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。（一般是command line程序）<br>使用方法：-XX:+UseSerialGC<br>Ps：在jdk client模式，不指定VM参数，默认是串行垃圾回收器</p><p><img src="/images/jvm_gc/jvm_gc3.jpg" alt="串行垃圾回收器"></p><p><strong>2、并行垃圾回收器  Parallel Garbage Collector</strong></p><p>并行垃圾回收器在进行垃圾回收时，同样会持有所有应用程序的线程，并冻结所有应用程序线程，来进行垃圾回收工作。<br>唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。</p><p><img src="/images/jvm_gc/jvm_gc4.jpg" alt="并行垃圾回收器"></p><p><strong>3、并发标记扫描垃圾回收器 CMS Garbage Collector</strong></p><p>Concurrent Mark Sweep (CMS)垃圾回收器使用并发标记算法，使用多线程来扫描heap memory来标记实例，然后清理被标记过的实例。<br>CMS垃圾回收器有时候会Hold所有的应用程序线程，但有时候只会Hold部分应用程序线程。</p><p>如果能分配更多的CPU给垃圾回收器，那么CMS会是一个比并行垃圾回收更好的选择。XX:+USeParNewGC</p><p><img src="/images/jvm_gc/jvm_gc5.jpg" alt="并发标记扫描垃圾回收器"></p><p><strong>4、G1垃圾回收器  G1 Garbage Collector</strong></p><p>G1垃圾回收器是用在heap memory很大的情况下，把heap划分为很多很多的region块，然后并行的对其进行垃圾回收。<br>G1垃圾回收器在清除实例所占用的内存空间后，还会做内存压缩。</p><p>G1垃圾回收器回收region的时候基本不会STW，而是基于 most garbage优先回收 的策略来对region进行垃圾回收的。</p><p>–XX:+UseG1GC</p><p>java8中，使用-XX:+UseStringDeduplication。这个优化会优化冗余的string为一个char数组。</p><p><img src="/images/jvm_gc/jvm_gc6.jpg" alt="G1垃圾回收器"></p><p>查看JVM使用的默认的垃圾收集器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><h2 id="jvm配置"><a href="#jvm配置" class="headerlink" title="jvm配置"></a>jvm配置</h2><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>Serial Garbage Collector 串行垃圾回收器</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel Garbage Collector并行垃圾回收器</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>CMS Garbage Collector并发标记垃圾回收器</td></tr><tr><td>-XX:ParallelCMSThreads=</td><td>CMS Collector – number of threads to use 并发标记垃圾回收器使用的线程数，通常是cpu个数</td></tr><tr><td>-XX:+UseG1GC</td><td>G1 Gargbage Collector 使用G1垃圾回收器</td></tr></tbody></table><p>优化选项</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-Xms</td><td>Initial heap memory size 初始化heap大小 -Xms512M</td></tr><tr><td>-Xmx</td><td>Maximum heap memory size 设置最大的heap大小</td></tr><tr><td>-Xmn</td><td>Size of Young Generation 年轻代的大小</td></tr><tr><td>-XX:PermSize</td><td>Initial Permanent Generation size 初始化永久带的大小</td></tr><tr><td>-XX:MaxPermSize</td><td>Maximum Permanent Generation size 最大的永久带大小</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>垃圾回收器目前分为四种类型, 串行，并行，并发标记，G1。</p><p>小数据量和小型应用，使用串行垃圾回收器即可。</p><p>对于对响应时间无特殊要求的，可以使用并行垃圾回收器和并发标记垃圾回收器。（中大型应用）</p><p>对于heap可以分配很大的中大型应用，使用G1垃圾回收器比较好，进一步优化和减少了GC暂停时间。</p><p>没有银弹，针对不同的场景，选用不同的垃圾回收器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-GC的定义和价值&quot;&gt;&lt;a href=&quot;#1-GC的定义和价值&quot; class=&quot;headerlink&quot; title=&quot;1. GC的定义和价值&quot;&gt;&lt;/a&gt;1. GC的定义和价值&lt;/h2&gt;&lt;p&gt;​    在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没
      
    
    </summary>
    
      <category term="java" scheme="https://huleski.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://huleski.github.io/tags/java/"/>
    
  </entry>
  
</feed>
