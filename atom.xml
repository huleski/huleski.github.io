<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Holeski的博客</title>
  
  <subtitle>你为什么这么熟练啊！？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huleski.github.com/"/>
  <updated>2019-07-10T07:31:28.299Z</updated>
  <id>http://huleski.github.com/</id>
  
  <author>
    <name>Holeski</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一台机器启动多个tomcat</title>
    <link href="http://huleski.github.com/2019/07/10/%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAtomcat/"/>
    <id>http://huleski.github.com/2019/07/10/一台机器启动多个tomcat/</id>
    <published>2019-07-10T03:43:47.000Z</published>
    <updated>2019-07-10T07:31:28.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>从<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">Apache官网</a>下载好Tomcat, 解压两份到不同的文件夹下即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>第一个tomcat不做任何修改，使用默认端口和配置</p><p>第二个tomcat需要编辑tomcat/conf目录下server.xml文件, 修改3个端口, 使其与前面的tomcat端口不同:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改关闭端口为8015, 第22行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8015"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改服务端口为8081, 第70行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8081"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改连接端口为8019, 第91行左右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8019"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成, 可以去启动两个tomcat了</p><p>看网上有些说还需要改redirectPort, 设置啥CATALINA_HOME等等, 都是多余的步骤, 完全不用</p><h2 id="指定JDK版本启动tomcat"><a href="#指定JDK版本启动tomcat" class="headerlink" title="指定JDK版本启动tomcat"></a>指定JDK版本启动tomcat</h2><p>有些复杂环境中有多个JDK, 默认会使用系统环境中的<code>JAVA_HOME</code>来启动tomcat, 如需要指定不同JDK版本启动tomcat, 这就需要修改tomcat的启动配置了</p><blockquote><p>在Windows中启动Tomcat时，双击startup.bat然后会调用catalina.bat文件，而catalina.bat会调用setclasspath.bat文件来获取JAVA_HOME和JRE_HOME这两个环境变量的值，因此只要在tomcat启动时指向特定的JDK即可</p></blockquote><ul><li>在Windows中, 需要在<code>setclasspath.bat</code>文件的开头处加入以下内容</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME=C:\Program Files\Java\jdk1.<span class="number">7</span>.<span class="number">0</span>_79</span><br><span class="line"><span class="built_in">set</span> JRE_HOME=C:\Program Files\Java\jdk1.<span class="number">7</span>.<span class="number">0</span>_79\jre</span><br></pre></td></tr></table></figure><ul><li>在Linux中, 则需要在<code>setclasspath.sh</code>文件的开头处加入以下内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=C:\Program Files\Java\jdk1.7.0_79</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=C:\Program Files\Java\jdk1.7.0_79\jre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Tomcat&quot;&gt;&lt;a href=&quot;#安装Tomcat&quot; class=&quot;headerlink&quot; title=&quot;安装Tomcat&quot;&gt;&lt;/a&gt;安装Tomcat&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://tomcat.apache.org/download-8
      
    
    </summary>
    
      <category term="tomcat" scheme="http://huleski.github.com/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="http://huleski.github.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建Hexo</title>
    <link href="http://huleski.github.com/2019/07/10/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo/"/>
    <id>http://huleski.github.com/2019/07/10/从零搭建Hexo/</id>
    <published>2019-07-10T03:15:12.000Z</published>
    <updated>2019-07-11T02:13:08.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><ul><li>升级主题到Next6, 字体样式失效, 图标也丢失, 启动还会报错 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost/:1 Refused to apply style from <span class="string">'http://localhost:4000/lib/font-awesome/css/font-awesome.min.css?v=4.6.2'</span> </span><br><span class="line">because its MIME <span class="built_in">type</span> (<span class="string">'text/html'</span>) is not a supported stylesheet MIME <span class="built_in">type</span>, and strict MIME checking is enabled.</span><br></pre></td></tr></table></figure><p>在hexo中有自带<code>font-awesome</code>字体的, 但是升级到hexo6时就没有了, 把next目录下（next -&gt; source -&gt; lib）的 <code>font-awesome</code> 文件夹复制到next6同样的目录下, 解决</p><p><img src="http://pubgmjp23.bkt.clouddn.com/%5BD60F5%7D%29IHOGB5%5BW9$T%29F8R.png" alt="font文件夹位置"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;碰到的问题&quot;&gt;&lt;a href=&quot;#碰到的问题&quot; class=&quot;headerlink&quot; title=&quot;碰到的问题&quot;&gt;&lt;/a&gt;碰到的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;升级主题到Next6, 字体样式失效, 图标也丢失, 启动还会报错 &lt;/li&gt;
&lt;/ul&gt;
&lt;figur
      
    
    </summary>
    
      <category term="Hexo" scheme="http://huleski.github.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://huleski.github.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决MySQL数据库Too many connections问题</title>
    <link href="http://huleski.github.com/2019/07/09/%E8%A7%A3%E5%86%B3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Too-many-connections%E9%97%AE%E9%A2%98/"/>
    <id>http://huleski.github.com/2019/07/09/解决MySQL数据库Too-many-connections问题/</id>
    <published>2019-07-09T04:06:05.000Z</published>
    <updated>2019-07-10T01:33:57.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h2><p>因为这种方法是临时修改, 连上MySQL后重启后会失效</p><p>连上MySQL后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> GLOBAL max_connections=500;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改mysql配置文件my.cnf</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在[mysqld]段中添加或修改max_connections值</span></span><br><span class="line">max_connections=500</span><br><span class="line"><span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><ul><li>查看mysql的最大连接数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%max_connections%'</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections |  500  |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>查询所有连接到这个服务器上的MySQL连接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><p>获取到MySQL数据连接列表后，每一条记录都会有一个进程ID号（在上表的第一列）。执行以下命令关闭一条连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中1180421是进程列表里找到并且要杀掉的进程号</span></span><br><span class="line">mysql&gt; <span class="built_in">kill</span> 1180421;</span><br></pre></td></tr></table></figure><ul><li>查看服务器响应的最大连接数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">'Max_used_connections'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一:&quot;&gt;&lt;/a&gt;方法一:&lt;/h2&gt;&lt;p&gt;因为这种方法是临时修改, 连上MySQL后重启后会失效&lt;/p&gt;
&lt;p&gt;连上MySQL后执行:&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="MySQL" scheme="http://huleski.github.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://huleski.github.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>docker安装JIRA和Confluence（破解版）以及JIRA版本升级方案</title>
    <link href="http://huleski.github.com/2019/07/08/docker%E5%AE%89%E8%A3%85JIRA%E5%92%8CConfluence%EF%BC%88%E7%A0%B4%E8%A7%A3%E7%89%88%EF%BC%89%E4%BB%A5%E5%8F%8AJIRA%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%96%B9%E6%A1%88/"/>
    <id>http://huleski.github.com/2019/07/08/docker安装JIRA和Confluence（破解版）以及JIRA版本升级方案/</id>
    <published>2019-07-08T08:41:58.000Z</published>
    <updated>2019-07-10T03:35:38.836Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将演示通过Docker安装JIRA和Confluence，并破解过程。<br>本文只做个人学习研究之用，不得用于商业用途！</p></blockquote><h2 id="安装JIRA-7-12-3"><a href="#安装JIRA-7-12-3" class="headerlink" title="安装JIRA (7.12.3)"></a>安装JIRA (7.12.3)</h2><h3 id="1-获取资源"><a href="#1-获取资源" class="headerlink" title="1. 获取资源"></a>1. 获取资源</h3><ul><li>Docker镜像 <a href="https://github.com/cptactionhank" target="_blank" rel="noopener">Github链接</a></li><li>补丁工具(atlassian-agent.jar) <a href="https://github.com/pengzhile/atlassian-agent/releases/download/v1.2/atlassian-agent-v1.2.zip" target="_blank" rel="noopener">Github链接</a>  原链接已失效, 附百度云:</li></ul><blockquote><p>百度网盘地址：</p><p>链接：<a href="https://pan.baidu.com/s/17zNwlp3sd1PLSCxPVjDwfQ" target="_blank" rel="noopener">https://pan.baidu.com/s/17zNwlp3sd1PLSCxPVjDwfQ</a> </p><p>提取码：b84z </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><h3 id="2-制作Docker破解容器"><a href="#2-制作Docker破解容器" class="headerlink" title="2. 制作Docker破解容器"></a>2. 制作Docker破解容器</h3><p>编写Dockerfile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM cptactionhank/atlassian-jira-software:7.12.3</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代理破解包加入容器</span></span><br><span class="line">COPY <span class="string">"atlassian-agent.jar"</span> /opt/atlassian/jira/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动加载代理包</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'export CATALINA_OPTS="-javaagent:/opt/atlassian/jira/atlassian-agent.jar $&#123;CATALINA_OPTS&#125;"'</span> &gt;&gt; /opt/atlassian/jira/bin/setenv.sh</span><br></pre></td></tr></table></figure><p>将下载好的<code>atlassian-agent.jar</code>文件放在Dockerfile同目录下，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- JIRA</span><br><span class="line">    |-Dockerfile</span><br><span class="line">    |-atlassian-agent.jar</span><br></pre></td></tr></table></figure><p>构建镜像, 执行命令(注意后面有一个点)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t jira/jira:v7.12.3 .</span><br></pre></td></tr></table></figure><p>构建成功后会显示 ‘Successfully built…` 字样</p><p>启动容器，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 10086:8080 \</span><br><span class="line">    -v /home/jira/data:/var/atlassian/jira \</span><br><span class="line">    --restart always --name=jira \</span><br><span class="line">    --health-cmd=<span class="string">"curl --silent --fail localhost:8080 || exit 1"</span> \</span><br><span class="line">    jira/jira:v7.12.3</span><br></pre></td></tr></table></figure><p>访问: `<a href="http://127.0.0.1:10086,可见JIRA配置页面" target="_blank" rel="noopener">http://127.0.0.1:10086,可见JIRA配置页面</a></p><h3 id="3-破解"><a href="#3-破解" class="headerlink" title="3. 破解"></a>3. 破解</h3><p>在见到JIRA配置页面后, 进行相关配置, 当要求输入许可证时</p><p><img src="http://pubgmjp23.bkt.clouddn.com/10973635-4168e67779acb0b2_%E7%9C%8B%E5%9B%BE%E7%8E%8B.web.jpg" alt="进入JIRA配置页面"></p><p>复制服务器ID: <code>BY9B-GWD1-1C78-K2DE</code>, 在存放<code>atlassian-agent.jar</code>的目录下执行命令, 生成许可证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需替换邮箱（test@test.com）、名称（JIRA）、</span></span><br><span class="line"><span class="comment"># 访问地址（http://192.168.0.1）、服务器ID（BY9B-GWD1-1C78-K2DE）</span></span><br><span class="line"><span class="comment"># 为你的信息</span></span><br><span class="line"></span><br><span class="line">java -jar atlassian-agent.jar -d -m <span class="built_in">test</span>@test.com -n JIRA -p jira -o http://192.168.0.89 -s BY9B-GWD1-1C78-K2DE</span><br></pre></td></tr></table></figure><p><img src="http://pubgmjp23.bkt.clouddn.com/xukezheng.jpg" alt="生成许可证"></p><p>复制下面生成的一长串许可证填写到页面中, 完成破解</p><h2 id="安装-Confluence（6-13-0"><a href="#安装-Confluence（6-13-0" class="headerlink" title="安装 Confluence（6.13.0)"></a>安装 Confluence（6.13.0)</h2><h3 id="1-编写Dockerfile文件"><a href="#1-编写Dockerfile文件" class="headerlink" title="1. 编写Dockerfile文件"></a>1. 编写Dockerfile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM cptactionhank/atlassian-confluence:6.13.0</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代理破解包加入容器</span></span><br><span class="line">COPY <span class="string">"atlassian-agent.jar"</span> /opt/atlassian/confluence/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动加载代理包</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'export CATALINA_OPTS="-javaagent:/opt/atlassian/confluence/atlassian-agent.jar $&#123;CATALINA_OPTS&#125;"'</span> &gt;&gt; /opt/atlassian/confluence/bin/setenv.sh</span><br></pre></td></tr></table></figure><h3 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2. 构建镜像"></a>2. 构建镜像</h3><p>将下载好的<code>atlassian-agent.jar</code>文件放在Dockerfile同目录下，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Confluence</span><br><span class="line">    |-Dockerfile</span><br><span class="line">    |-atlassian-agent.jar</span><br></pre></td></tr></table></figure><p>构建镜像, 执行命令(注意后面有一个点)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t confluence/confluence:6.13.0 .</span><br></pre></td></tr></table></figure><p>启动容器，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8090:8090 confluence/confluence:6.13.0</span><br></pre></td></tr></table></figure><p>访问<code>http://127.0.0.1:8090</code>,参照JIRA的安装流程，进行操作。</p><p>生成confluence许可方法可参照前面JIRA的破解过程, 这里不再赘述</p><h2 id="JIRA版本升级"><a href="#JIRA版本升级" class="headerlink" title="JIRA版本升级"></a>JIRA版本升级</h2><p>可以参考<a href="https://confluence.atlassian.com/jirakb/startup-check-jira-data-version-too-low-to-be-upgraded-872266914.html" target="_blank" rel="noopener">官方文档</a></p><p><img src="http://pubgmjp23.bkt.clouddn.com/jira.png" alt="升级步骤"></p><p>由于之前安装的是jira6.4版本的, 现在需要升级到7.12.3版本, 根据官方提示需要先升级到7.0版本的jira再过渡升级到7.12.3</p><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1. 备份数据"></a>1. 备份数据</h3><p><strong>a. 备份数据库</strong></p><p>   登录jira6.4版本, 进入设置 -&gt; 系统 -&gt; 备份系统, 输入备份的文件名字: 比如jira</p><p><img src="http://pubgmjp23.bkt.clouddn.com/2E6%7D47Y%29@KMCUP3%25%295B%29%60%7BO.png" alt="备份系统"></p><p>点击备份后会在备份界面提示的某个路径下生成一个<code>jira.zip</code>数据库的备份文件</p><p><strong>b . 备份图片</strong></p><p>复制 <code>/var/atlassian/application-data/jira/data</code>下的<code>attachments</code>和<code>avatars</code>文件夹出来,备份好</p><h3 id="2-升级过渡版"><a href="#2-升级过渡版" class="headerlink" title="2. 升级过渡版"></a>2. 升级过渡版</h3><p>如果不过数据库文件过渡处理, 在jira v7.12.3中是无法使用的</p><p>获取JIRA v7.0.11 镜像并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull dchevell/jira-software:7.0.11</span><br><span class="line">docker run -d -p 8080:8080 dchevell/jira-software:7.0.11</span><br></pre></td></tr></table></figure><p>启动后访问 <code>http://127.0.0.1:8080</code>, 开始配置, 当需要许可证时, 上面的方法破解不了, 由于只是做一个过度版本, 可以去官网注册然后申请一个30天有效期的许可证, 然后输入进去就好了</p><p>同样在备份系统的同级目录中点击恢复系统</p><p><img src="http://pubgmjp23.bkt.clouddn.com/ertysdysdrtysert.png" alt="恢复系统"></p><p>按照提示将前面备份好的文件放到他指定目录下,点击复原, 如果需要填写许可证那就填写许可证在复原</p><p>复原成功后再重复上一步骤进行备份<br>备份后将在 docker容器 <code>/var/atlassian/jira/export</code>目录下生成一个<code>.zip</code>数据库的备份文件</p><h3 id="3-升级最终版"><a href="#3-升级最终版" class="headerlink" title="3. 升级最终版"></a>3. 升级最终版</h3><p>按照上面的步骤把jira v7.12.3运行起来, 并将数据库备份文件放入恢复界面指定的目录之下进行数据复原.</p><p>把前面图片备份文件分别放入<code>/var/atlassian/application-data/jira/data/</code>下即可</p><p>升级成功!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文将演示通过Docker安装JIRA和Confluence，并破解过程。&lt;br&gt;本文只做个人学习研究之用，不得用于商业用途！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装JIRA-7-12-3&quot;&gt;&lt;a href=&quot;#安装JIRA-7-
      
    
    </summary>
    
      <category term="JIRA" scheme="http://huleski.github.com/categories/JIRA/"/>
    
    
      <category term="docker" scheme="http://huleski.github.com/tags/docker/"/>
    
      <category term="JIRA" scheme="http://huleski.github.com/tags/JIRA/"/>
    
  </entry>
  
  <entry>
    <title>初识JMX</title>
    <link href="http://huleski.github.com/2019/06/15/%E5%88%9D%E8%AF%86JMX/"/>
    <id>http://huleski.github.com/2019/06/15/初识JMX/</id>
    <published>2019-06-15T12:47:00.000Z</published>
    <updated>2019-06-18T12:50:00.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JXM简介"><a href="#JXM简介" class="headerlink" title="JXM简介"></a>JXM简介</h2><p>试想，一个正在运行中的程序，我们如果想改变程序中的一些属性，可以通过什么方法呢？可能有这么几个方法：</p><ul><li>对于服务器式的程序，可以制作管理页面，通过HTTP post与servlet来更改服务器端程序的属性。</li><li>对于服务器式的程序，还可以通过SOAP方式。但这需要程序开启了SOAP端的服务。</li><li>可以使用RMI远程调用。但这需要设计开启RMI服务。</li><li>如果是SWT或Swing的程序，则可以通过设计UI管理界面，使用户可以和程序内部交互。</li><li>还有一种方式，是将可改变的属性放入配置文件XML，properties或数据库，程序轮询配置文件，以求获取最新的配置。</li></ul><p>上面几个方法都是常见，但却无法通用的。所谓通用，是指解决方案符合一个标准，使得任何符合此标准的工具都能解析针对此标准的方案实现。这样A公司设计的方案，B公司可以根据标准来解析。JMX就是Java管理标准。</p><p>对于一些参数的修改，网上有一段描述还是比较形象的：</p><ol><li>程序初哥一般是写死在程序中，到要改变的时候就去修改代码，然后重新编译发布。</li><li>程序熟手则配置在文件中（JAVA一般都是properties文件），到要改变的时候只要修改配置文件，但还是必须重启系统，以便读取配置文件里最新的值。</li><li>程序好手则会写一段代码，把配置值缓存起来，系统在获取的时候，先看看配置文件有没有改动，如有改动则重新从配置里读取，否则从缓存里读取。</li><li>程序高手则懂得物为我所用，用JMX把需要配置的属性集中在一个类中，然后写一个MBean，再进行相关配置。另外JMX还提供了一个工具页，以方便我们对参数值进行修改。</li></ol><p>JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。JMX让程序有被管理的功能，例如你开发一个WEB网站，它是在24小时不间断运行，那么你肯定会对网站进行监控，如每天的UV、PV是多少；又或者在业务高峰的期间，你想对接口进行限流，就必须去修改接口并发的配置值。</p><p>应用场景：中间件软件WebLogic的管理页面就是基于JMX开发的，而JBoss则整个系统都基于JMX构架。</p><h2 id="JMX的构成"><a href="#JMX的构成" class="headerlink" title="JMX的构成"></a>JMX的构成</h2><p>JMX由三部分组成：</p><ul><li><p>基础层：程序端的Instrumentation, 我把它翻译成可操作的仪器。这部分就是指的MBean. MBean类似于JavaBean。最常用的MBean则是Standard MBean和MXBean.</p></li><li><p>适配层：程序端的JMX agent. 这部分指的是MBean Server. MBean Server则是启动与JVM内的基于各种协议的适配器。用于接收客户端的调遣，然后调用相应的MBeans.</p></li><li><p>接入层：客户端的Remote Management. 这部分则是面向用户的程序。此程序则是MBeans在用户前投影，用户操作这些投影，可以反映到程序端的MBean中去。这内部的原理则是client通过某种协议调用agent操控MBeans.<br>JMX agent与Remote Management之间是通过协议链接的，这协议可能包含：</p><ul><li>HTTP</li><li>SNMP</li><li>RMI</li><li>IIOP</li></ul></li></ul><p>JMX agent中有针对上面协议的各种适配器。可以解析通过相应协议传输过来的数据。Remote Management client则可以用现成的工具，如JConsole, 也可以自己书写java code。</p><h2 id="实现一个JMX程序"><a href="#实现一个JMX程序" class="headerlink" title="实现一个JMX程序"></a>实现一个JMX程序</h2><p> 1、 首先定义一个MBean接口，接口的命名规范为以具体的实现类为前缀（这个规范很重要）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloMBean</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">(String str)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTelephone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义一个实现类，实现上面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该类名称必须与实现的接口的前缀保持一致（即MBean前面的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">HelloMBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get Telephone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloWorld:"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get name 123"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"set name 123"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get age 123"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"set age 123"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义agent层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> javax.management.JMException;</span><br><span class="line"><span class="keyword">import</span> javax.management.MBeanServer;</span><br><span class="line"><span class="keyword">import</span> javax.management.ObjectName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMException, Exception </span>&#123;</span><br><span class="line">          <span class="comment">// 通过工厂类获取MBeanServer，用来做MBean的容器 </span></span><br><span class="line">         MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">          <span class="comment">// ObjectName中的取名是有一定规范的，格式为：“域名：name=MBean名称”，其中域名和MBean的名称可以任意取。</span></span><br><span class="line">         ObjectName helloName = <span class="keyword">new</span> ObjectName(<span class="string">"jmxBean:name=hello"</span>);</span><br><span class="line">         <span class="comment">//将Hello这个类注入到MBeanServer中，注入需要创建一个ObjectName类</span></span><br><span class="line">         server.registerMBean(<span class="keyword">new</span> Hello(), helloName);</span><br><span class="line">         Thread.sleep(<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的JMX的DEMO已经写完了，现在我们通过JDK提供的Jconsole来进行操作。</p><p>4、在JDK安装路径 ·JAVA_HOME\bin· 下找到 jconsole.exe 这个小工具，双击打开。</p><p>在本地进程中找到 <code>HelloAgent</code> 并双击打开</p><p>在当前界面上，我们可以给程序中HelloMBean的属性赋值，也可以调用其中的方法</p><p>这样就做到动态修改运行中程序的状态进而管理程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JXM简介&quot;&gt;&lt;a href=&quot;#JXM简介&quot; class=&quot;headerlink&quot; title=&quot;JXM简介&quot;&gt;&lt;/a&gt;JXM简介&lt;/h2&gt;&lt;p&gt;试想，一个正在运行中的程序，我们如果想改变程序中的一些属性，可以通过什么方法呢？可能有这么几个方法：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="JMX" scheme="http://huleski.github.com/categories/JMX/"/>
    
    
      <category term="JMX" scheme="http://huleski.github.com/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>java爬虫-webmagic入门</title>
    <link href="http://huleski.github.com/2019/06/14/java%E7%88%AC%E8%99%AB-webmagic%E5%85%A5%E9%97%A8/"/>
    <id>http://huleski.github.com/2019/06/14/java爬虫-webmagic入门/</id>
    <published>2019-06-14T10:48:13.000Z</published>
    <updated>2019-07-06T03:18:34.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webmagic简介"><a href="#webmagic简介" class="headerlink" title="webmagic简介"></a>webmagic简介</h2><p><img src="https://camo.githubusercontent.com/8b3a6d93d95d39147ef93f5021f6b69255bda888/687474703a2f2f7765626d616769632e696f2f696d616765732f6c6f676f2e6a706567" alt="webmagic"></p><p><a href="http://webmagic.io/" target="_blank" rel="noopener">官方网站</a> </p><blockquote><p>webmagic是一个开源的Java垂直爬虫框架，目标是简化爬虫的开发流程，让开发者专注于逻辑功能的开发。webmagic的核心非常简单，但是覆盖爬虫的整个流程，也是很好的学习爬虫开发的材料。</p></blockquote><p>webmagic的主要特色：</p><ul><li>完全模块化的设计，强大的可扩展性。</li><li>核心简单但是涵盖爬虫的全部流程，灵活而强大，也是学习爬虫入门的好材料。</li><li>提供丰富的抽取页面API。</li><li>无配置，但是可通过POJO+注解形式实现一个爬虫。</li><li>支持多线程。</li><li>支持分布式。</li><li>支持爬取js动态渲染的页面。</li><li>无框架依赖，可以灵活的嵌入到项目中去。</li></ul><p>该项目是参考了:</p><p><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">python爬虫 scrapy</a></p><p><a href="http://git.oschina.net/l-weiwei/spiderman" target="_blank" rel="noopener">Java爬虫 Spiderman</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>webmagic使用maven管理依赖，在项目中添加对应的依赖即可使用webmagic：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>us.codecraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webmagic-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>us.codecraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webmagic-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意: </strong> 这里都是参考官方文档, 但实际上maven库的包源有bug, 不过作者已经在源代码里修复了, 需要copy源代码重新编译打包</p><p>克隆源代码 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/code4craft/webmagic.git</span><br></pre></td></tr></table></figure><p>或者直接下载zip源码压缩包, 下载完解压即可</p><p>下载完成后导入到开发工具中, 重新 install webmagic-core模块即可</p><p>创建第一个爬虫:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GithubRepoPageProcessor</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分一：抓取网站的相关配置，包括编码、抓取间隔、重试次数等</span></span><br><span class="line">    <span class="keyword">private</span> Site site = Site.me().setRetryTimes(<span class="number">3</span>).setSleepTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// process是定制爬虫逻辑的核心接口，在这里编写抽取逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 部分二：定义如何抽取页面信息，并保存下来</span></span><br><span class="line">        page.putField(<span class="string">"author"</span>, page.getUrl().regex(<span class="string">"https://github\\.com/(\\w+)/.*"</span>).toString());</span><br><span class="line">        page.putField(<span class="string">"name"</span>, page.getHtml().xpath(<span class="string">"//h1[@class='entry-title public']/strong/a/text()"</span>).toString());</span><br><span class="line">        <span class="keyword">if</span> (page.getResultItems().get(<span class="string">"name"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//skip this page</span></span><br><span class="line">            page.setSkip(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.putField(<span class="string">"readme"</span>, page.getHtml().xpath(<span class="string">"//div[@id='readme']/tidyText()"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 部分三：从页面发现后续的url地址来抓取</span></span><br><span class="line">        page.addTargetRequests(page.getHtml().links().regex(<span class="string">"(https://github\\.com/[\\w\\-]+/[\\w\\-]+)"</span>).all());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> site;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Spider.create(<span class="keyword">new</span> GithubRepoPageProcessor())</span><br><span class="line">                <span class="comment">//从"https://github.com/code4craft"开始抓</span></span><br><span class="line">                .addUrl(<span class="string">"https://github.com/code4craft"</span>)</span><br><span class="line">                <span class="comment">//开启5个线程抓取</span></span><br><span class="line">                .thread(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">//启动爬虫</span></span><br><span class="line">                .run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行, 就能看到爬虫工作了</p><p>如果运行的时候报错 <code>javax.net.ssl.SSLException: Received fatal alert: protocol_version</code> 那是你没有编译源码打包.</p><p>代码中注释已经很详细了, 相信大家也大概明白爬取的过程了. 更详细的爬虫教程看作者的<a href="http://webmagic.io/docs/" target="_blank" rel="noopener">官方教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webmagic简介&quot;&gt;&lt;a href=&quot;#webmagic简介&quot; class=&quot;headerlink&quot; title=&quot;webmagic简介&quot;&gt;&lt;/a&gt;webmagic简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubuserconte
      
    
    </summary>
    
      <category term="爬虫" scheme="http://huleski.github.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://huleski.github.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下几个有趣的命令</title>
    <link href="http://huleski.github.com/2019/05/20/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://huleski.github.com/2019/05/20/Linux系统下几个有趣的命令/</id>
    <published>2019-05-20T11:51:12.000Z</published>
    <updated>2019-05-20T12:22:23.509Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。今天我们就来介绍几个有趣的Linux命令, 来体验一波程序彩蛋之美。</p><p>文章参考: <a href="https://www.jianshu.com/p/08e9094f61ce" target="_blank" rel="noopener">Linux系统下好玩有趣的命令，你又用过几个？</a></p><p>由于原文都是在Ubuntu系统下安装使用的, 而我自己是在CentOS7系统下操作, 偶尔有些不同, 我也只选择了其中几个很有趣的试了试</p><h2 id="sl-（Steam-Locomotive）"><a href="#sl-（Steam-Locomotive）" class="headerlink" title="sl （Steam Locomotive）"></a>sl （Steam Locomotive）</h2><p>安装, 这个是最简单的, 经常在你想要查看当前目录的时候错误的输入了<code>sl</code>, 现在就回出现一辆小火车开过的动画…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sl</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl</span><br></pre></td></tr></table></figure><h2 id="oneko"><a href="#oneko" class="headerlink" title="oneko"></a>oneko</h2><p>撸猫指令, oneko会生成一只图像猫, 在屏幕上乱跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install oneko</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneko</span><br></pre></td></tr></table></figure><h2 id="cmatrix"><a href="#cmatrix" class="headerlink" title="cmatrix"></a>cmatrix</h2><p>该指令会在屏幕上下一场字符雨</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 下载压缩包</span></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz</span><br><span class="line"><span class="comment">## 解压</span></span><br><span class="line">tar xvf cmatrix-1.2a.tar.gz</span><br><span class="line"><span class="comment">## 进入安装目录</span></span><br><span class="line"><span class="built_in">cd</span> cmatrix-1.2a</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">yum install ncurses-devel</span><br><span class="line"><span class="comment">## 编译源码并安装, 需要有gcc,gcc-c++, 如果没有就yum安装</span></span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="comment">## 安装完毕, 运行</span></span><br><span class="line">cmatrix</span><br></pre></td></tr></table></figure><p>启动成功后, 有看到字符雨, 按<code>q</code>退出</p><h2 id="ASCIIquarium"><a href="#ASCIIquarium" class="headerlink" title="ASCIIquarium"></a>ASCIIquarium</h2><p>彩蛋：把你的linux终端变成一个海洋世界，各种生物在不断呈现，有鱼、有水、有草…, 好鬼酷哦(wzr…)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装依赖工具</span></span><br><span class="line">yum -y install ncurses-devel perl-CPAN libyaml-devel perl-CGI perl-Curses perl-ExtUtils-MakeMaker</span><br><span class="line"><span class="comment">## 安装依赖文件</span></span><br><span class="line">wget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gz</span><br><span class="line">tar -zxvf Term-Animation-2.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> Term-Animation-2.4/</span><br><span class="line">perl Makefile.PL &amp;&amp; make</span><br><span class="line">make install</span><br><span class="line"><span class="comment">## 安装ASCIIquarium</span></span><br><span class="line">wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gz</span><br><span class="line">tar -zxvf asciiquarium.tar.gz</span><br><span class="line"><span class="built_in">cd</span> asciiquarium_1.1/</span><br><span class="line">cp asciiquarium /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">chmod 755 /usr/<span class="built_in">local</span>/bin/asciiquarium</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">asciiquarium</span><br></pre></td></tr></table></figure><p>同样的运行成功后按<code>q</code>退出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。今天我们就来介绍几个有趣的Linux命令, 来体验一
      
    
    </summary>
    
      <category term="Linux" scheme="http://huleski.github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://huleski.github.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>QQ/微信机器人的安装使用</title>
    <link href="http://huleski.github.com/2019/05/12/QQ-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://huleski.github.com/2019/05/12/QQ-微信机器人的安装使用/</id>
    <published>2019-05-12T08:39:47.000Z</published>
    <updated>2019-05-14T12:33:43.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常在微信/QQ上看到可以自动聊天的机器人, 感觉很有趣, 今天我们就可以来创建这样一个机器人. </p><p><strong>前期准备</strong>: </p><blockquote><p>在<a href="http://www.tuling123.com" target="_blank" rel="noopener">图灵机器人网站</a>上注册一个账号, 注册成功后在网站上创建一个机器人, 勾选qq/微信即可, 创建完成后会有一个apikey, 记住这个apikey, 后面会用到. </p></blockquote><p><strong>图灵机器人的作用</strong>: </p><blockquote><p>在聊天机器人中, 当我们发送消息给机器人账号时, 机器人账号会将获取到的消息通过apikey发到图灵机器人网站上, 然后图灵机器人背后使用机器学习+大数据分析相结合的人工智能技术得出消息的回复, 并把该回复响应给机器人账号,进而呈现在你的屏幕上, 这就是整个聊天机器人的工作原理</p></blockquote><blockquote><p>注册好图灵机器人账号后, 它会免费提供给我们每天100次的调用次数, 也就是说他可以每天跟我们对话100次, 如果你觉得少了也可以升级到收费版, 调用次数会大幅提升.</p></blockquote><h1 id="微信机器人"><a href="#微信机器人" class="headerlink" title="微信机器人"></a>微信机器人</h1><p>参考<a href="https://github.com/pig6/wxrobot" target="_blank" rel="noopener">项目</a>, 该项目使用python3来运行的, 因此我们先安装python3, 去<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python官网</a>下载, 这里我选择Windows版本, 安装的时候有个地方<code>add to path</code> 需要勾选, 其他都点下一步就安装好了.<br>验证是否安装成功, 在CMD命令行窗口里输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><p>如果输出版本号, 则表示安装成功</p><p><a href="https://github.com/pig6/wxrobot" target="_blank" rel="noopener">从github下载项目源码</a></p><p>下载后进入项目目录,当前目录下应该可以看到<code>robot.py</code>文件, 如果是下载zip包则先解压缩</p><p>安装依赖文件, 打开CMD窗口输入下面命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -U wxpy -i <span class="string">"https://pypi.doubanio.com/simple/"</span></span><br></pre></td></tr></table></figure><p>等依赖安装结束后, 启动项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python robot.py</span><br></pre></td></tr></table></figure><p>此时会出现一个登陆用的二维码, 用手机微信扫码登陆, 登陆成功后会提示登陆成功, 这样一个微信机器人就创建成功了, 试着发消息给这个微信号, 和他聊聊天吧!</p><p><strong>注意</strong>: </p><ul><li>如果在扫码登陆的时候报错, 很可能是因为你使用了新申请的微信, 腾讯为了安全考虑做出的新号登录限制, 一个号是否可以用来作为机器人账号, 可以先试着登陆<a href="https://wx.qq.com/" target="_blank" rel="noopener">网页版微信</a>成功与否来判断, 因为该项目的原理就是使用了网页端微信的api来收发消息的</li><li>该项目里使用了原作者自己提供的图灵机器人apikey, 可能由于使用次数达到限制而无法自动回复, 此时我们应该使用自己图灵账号的apikey了, 打开 <code>config.py</code> , 修改里面 <code>tuling_api_key</code> 这一项的值为自己的apikey.</li></ul><h1 id="QQ机器人"><a href="#QQ机器人" class="headerlink" title="QQ机器人"></a>QQ机器人</h1><h2 id="酷Q"><a href="#酷Q" class="headerlink" title="酷Q"></a>酷Q</h2><p>酷Q是一款免费的qq机器人, 以前是基于webqq、smartQQ协议做的自动收发消息功能, 但现在腾讯已经放弃了网页版的qq, 也就是以前的webqq、smartQQ协议都不行了。后来听说酷Q按照安卓的qq协议反编译出的，因此最新版应该是基于安卓协议的。</p><h2 id="下载Windows版安装"><a href="#下载Windows版安装" class="headerlink" title="下载Windows版安装"></a>下载Windows版安装</h2><p>从<a href="https://cqp.cc/t/23253" target="_blank" rel="noopener">酷Q官网</a>下载软件压缩包，直接解压运行即可，此时会要求登录qq账号来作为机器人账号，建议使用小号来登录。登录完成后，会有提示下一步如何操作，根据提示完成后就可以大致明白如何使用QQ机器人的聊天等功能了。如需启用图灵机器人, 设置图灵的apikey后就可以聊天了.</p><p>这是最基本的功能，他还有一个强大之处在于，他的插件扩展功能更强大</p><p>在酷Q的<a href="https://cqp.cc/b/app" target="_blank" rel="noopener">应用官网</a>，插件在酷Q官网叫应用，选择一个应用下载吧（需要注册登录），下载完后缀名是cpk的文件后，直接放入酷Q安装目录的app文件夹中，重启酷Q就可以加载进去，然后就可以体验机器人的乐趣了。</p><h2 id="安装Linux版"><a href="#安装Linux版" class="headerlink" title="安装Linux版"></a>安装Linux版</h2><p>一般也不会挂着机器人在Windows上，所以如果我们有linux服务器，就比较好挂着机器人了。</p><p>这里使用的Docker安装酷Q，详细查看<a href="https://cqp.cc/t/34558" target="_blank" rel="noopener">官网介绍</a></p><p>首先确保Linux已经装好Docker了，接下来拉取镜像运行就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>然后运行 酷Q 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=coolq --rm -p 9000:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>运行后，会看到控制台中输出一系列日志。当你看到 <code>[CQDaemon] Started CoolQ</code>  时，说明已启动成功。<br>此时，在浏览器中访问 <code>http://你的服务器IP:9000</code> 即可看到远程操作登录页面，输入密码123456，即可看到 酷Q Air 的登录界面啦。<br>在登录后，右键点击悬浮窗 -&gt; 昵称 -&gt; 勾选「自动登录」，即可保证 酷Q 能自动登录。</p><p>这时候如果关闭linux界面酷Q就会停了, 所以我们需要后台运行酷Q:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=coolq -d -p 9000:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq</span><br></pre></td></tr></table></figure><p>查看运行状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs coolq</span><br></pre></td></tr></table></figure><p>启动/停止服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start coolq</span><br><span class="line">docker stop coolq</span><br></pre></td></tr></table></figure><p>如果想安装插件, 把插件放入挂载的文件<code>/root/coolq-data/app</code>, 重启酷Q即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经常在微信/QQ上看到可以自动聊天的机器人, 感觉很有趣, 今天我们就可以来创建这样一个机器人. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前期准备&lt;
      
    
    </summary>
    
      <category term="机器人" scheme="http://huleski.github.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="机器人" scheme="http://huleski.github.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装Elasticsearch</title>
    <link href="http://huleski.github.com/2019/05/06/CentOS7%E5%AE%89%E8%A3%85Elasticsearch/"/>
    <id>http://huleski.github.com/2019/05/06/CentOS7安装Elasticsearch/</id>
    <published>2019-05-06T03:37:41.000Z</published>
    <updated>2019-07-11T02:12:55.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>Elasticsearch 目前有三个常用的稳定的主版本：2.x，5.x，6.x, 目前最新是7.0.0</p><blockquote><p>中间没有3.x和4.x是为了ELK（ElasticSearch, logstash, kibana）技术栈的版本统一，免的给用<br>户带来混乱。</p></blockquote><p>版本选择可以从以下几个方面考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">版本问题</span><br><span class="line">2.x 版本较老，无法体验新功能，且性能不如 5.x。</span><br><span class="line">6.x 版本有点新，网上资料相对比较少（开发时间充足的可以研究）。</span><br><span class="line"></span><br><span class="line">数据迁移</span><br><span class="line">2.x 版本数据可以直接迁移到 5.x；</span><br><span class="line">5.X 版本的数据可以直接迁移到 6.x； 但是 2.x 版本数据无法直接迁移到 6.x。</span><br><span class="line"></span><br><span class="line">周边工具</span><br><span class="line">2.x 版本周边工具版本比较混乱；Kibana 等工具的对应版本需要自己查，不好匹配。</span><br><span class="line">5.x 之后 Kibana 等工具的主版本号进行了统一。</span><br><span class="line"></span><br><span class="line">Sql 语法支持</span><br><span class="line">2.x，5.x，6.x 都可以安装 Elasticsearch-sql 插件，使用熟悉的SQL语法查询 Elasticsearch。</span><br><span class="line">6.3.0 以后内置支持 SQL 模块，这个 SQL 模块是属于 X-Pack 的一部分。</span><br></pre></td></tr></table></figure><p>我选择目前最新的5.x版: <code>elasticsearch-5.6.16</code></p><h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><strong>注意: Elasticsearch5.0之后的版本至少需要Java 8</strong></p><p>下载对应版本安装包: <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">官方下载地址</a></p><p>下载后解压即可使用, 执行以下命令启动:</p><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><p><strong>Windows</strong> 进入elasticsearch安装目录/bin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双击 elasticsearch.bat</span><br></pre></td></tr></table></figure><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>CentOS版太大了, 我选择alpine版的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:5.6-alpine</span><br></pre></td></tr></table></figure><p><strong>启动容器</strong></p><p>在启动容器之前, 容器挂载的配置文件目录下面得要有配置文件，不然es是起不来的，比较方便的办法是，先不挂载启动es，然后用docker cp命令，把配置文件复制到宿主机挂载目录，然后再进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9200:9200 -p 9300:9300 --name=elasticsearch elasticsearch:5.6-alpine</span><br><span class="line"></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/config /data/software/elasticsearch/config </span><br><span class="line"></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/data /data/software/elasticsearch/data</span><br><span class="line"></span><br><span class="line">docker stop elasticsearch</span><br><span class="line"></span><br><span class="line">docker rm elasticsearch</span><br><span class="line"></span><br><span class="line">如果需要更改配置，可以直接修改config目录下的  elasticsearch.yml 文件，然后启动es</span><br><span class="line"></span><br><span class="line">docker run -d -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span>  -e ES_JAVA_OPTS=<span class="string">"-Xms512m -Xmx512m"</span> \</span><br><span class="line">-v /data/software/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/software/elasticsearch/config:/usr/share/elasticsearch/config \</span><br><span class="line">-v /data/software/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">--restart unless-stopped --name=elasticsearch elasticsearch:5.6-alpine</span><br></pre></td></tr></table></figure><p>检查es是否安装成功: 访问 <code>http://es_serverIp:9200</code></p><h2 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h2><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">下载地址</a></p><p>下载对应版本, 解压放入es安装目录中的plugin文件夹中, 重启es即可</p><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>Kibana 和 elasticsearch 同属于 elastic 公司。 Kibana是一个开源分析和可视化平台，旨在与Elasticsearch协同工作。使用Kibana搜索，可以查看和与存储在 Elasticsearch 索引中的数据进行交互。您可以轻松地执行高级数据分析，并在各种图表，表格和地图中可视化您的数据。</p><p><strong>Windows</strong></p><p>从<a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">官方下载地址</a>中下载与elasticsearch 版本对应 的Kibana, 解压即可使用:</p><ul><li>下载并解压缩 Kibana。</li><li>在编辑器中打开 <code>config/kibana.yml</code>。</li><li>设置 <code>elasticsearch.url</code> 为您的Elasticsearch实例，如本地：elasticsearch.url: “<a href="http://localhost:9200&quot;(与es装在同一机器可以不用设置)。" target="_blank" rel="noopener">http://localhost:9200&quot;(与es装在同一机器可以不用设置)。</a></li><li>运行bin/kibana.bat。</li><li>浏览器输入 <a href="http://localhost:5601。" target="_blank" rel="noopener">http://localhost:5601。</a></li></ul><p><strong>CentOS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:5.6.16</span><br><span class="line">docker run --init -d --name kibana --restart unless-stopped --link elasticsearch -p 5601:5601 kibana:5.6.16</span><br></pre></td></tr></table></figure><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题:"></a>碰到的问题:</h2><ul><li>不能以root身份启动elasticsearch, 否则会报错, 执行以下命令:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个非root用户, 比如创建新用户elasticsearch</span></span><br><span class="line">adduser elasticsearch</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">chown -R elasticsearch /elasticsearch安装目录</span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su elasticsearch</span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><ul><li>elasticsearch默认开启9200端口作为接收http请求, 如果想要开启9300端口:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑elasticsearch配置文件</span></span><br><span class="line">vi elasticsearch.yml</span><br><span class="line"><span class="comment"># 文件添加配置: </span></span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li><code>max virtual memory areas vm.max_map_count [65530] is too low</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件, 在最后添加一行  vm.max_map_count=655300</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令重新加载文件 </span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启elasticsearch: </span></span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><ul><li><code>max number of threads [1024] for user [elsearch] is too low, increase to at least [4096]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim /etc/security/limits.d/90-nproc.conf</span><br><span class="line"><span class="comment"># 将下面</span></span><br><span class="line">* soft nproc 1024</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line">* soft nproc 4096</span><br></pre></td></tr></table></figure><ul><li><code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vim /etc/security/limits.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最下面添加以下内容</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><ul><li>修改JVM参数(可选)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化内存分配2g</span></span><br><span class="line">-Xms2g</span><br><span class="line"><span class="comment"># 最大分配内存2g</span></span><br><span class="line">-Xmx2g</span><br></pre></td></tr></table></figure><ul><li>elasticsearch版本升级</li></ul><p>详情参考: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html" target="_blank" rel="noopener">官方文档</a></p><p>升级需要考虑到数据迁移, 不过也不难</p><p>安装好新版elasticsearch后, 修改新ES中的配置<code>elasticsearch.yml</code>文件,在里面添加一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个ip以逗号','隔开, 或者 127.0.10.*:9200</span></span><br><span class="line">reindex.remote.whitelist: oldhost:9200</span><br></pre></td></tr></table></figure><p>然后向新ES执行下面请求即可</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  "source": &#123;   // 获取来源的索引库</span><br><span class="line">    "remote": &#123;</span><br><span class="line">      "host": "http://oldhost:9200",</span><br><span class="line">      "username": "user",</span><br><span class="line">      "password": "password"</span><br><span class="line">    &#125;,</span><br><span class="line">    "index": "indexName",</span><br><span class="line">    "query": &#123;</span><br><span class="line">      "match": &#123;</span><br><span class="line">        "test": "data"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "dest": &#123;    // 生成的目标索引库</span><br><span class="line">    "index": "indexName"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本选择&quot;&gt;&lt;a href=&quot;#版本选择&quot; class=&quot;headerlink&quot; title=&quot;版本选择&quot;&gt;&lt;/a&gt;版本选择&lt;/h3&gt;&lt;p&gt;Elasticsearch 目前有三个常用的稳定的主版本：2.x，5.x，6.x, 目前最新是7.0.0&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://huleski.github.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://huleski.github.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门教程</title>
    <link href="http://huleski.github.com/2019/04/30/Elasticsearch%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://huleski.github.com/2019/04/30/Elasticsearch入门教程/</id>
    <published>2019-04-30T09:49:33.000Z</published>
    <updated>2019-07-09T07:17:01.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><p>Elasticsearch是一个高度可扩展的、开源的、基于 Lucene 的全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据，并支持多租户。</p><p>它使用Java开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><blockquote><p>集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。</p><p>集群由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入集群的话，则该节点只能是集群的一部分。<br>确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。</p></blockquote><h4 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点(Node)"></a>节点(Node)</h4><blockquote><p>一个运行的 ES 实例就是一个节点，节点存储数据并参与集群的索引和搜索功能。<br>就像集群一样，节点由名称标识，默认情况下，该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果不需要默认值，可以定义所需的任何节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中哪些服务器与 Elasticsearch 集群中的哪些节点相对应。</p><p>可以将节点配置为按集群名称加入特定集群。默认情况下，每个节点都设置为加入一个名为 cluster 的 elasticsearch 集群，这意味着如果您在网络上启动了许多节点并且假设它们可以相互发现 - 它们将自动形成并加入一个名为 elasticsearch 的集群。</p></blockquote><h4 id="索引（名词）"><a href="#索引（名词）" class="headerlink" title="索引（名词）"></a>索引（名词）</h4><blockquote><p>一个索引类似于传统关系数据库中的一个数据库 ，是一个存储关系型文档的地方，是ES对逻辑数据的逻辑存储，索引的结构是为快速有效的全文检索做准备。</p></blockquote><h4 id="索引（动词）"><a href="#索引（动词）" class="headerlink" title="索引（动词）"></a>索引（动词）</h4><blockquote><p>索引一个文档就是存储一个文档到一个索引（名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p></blockquote><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><blockquote><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted file)。</p></blockquote><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><blockquote><p>存储在ES上的主要实体叫文档</p></blockquote><h4 id="文档类型（在-6-0-0-及以上废弃）"><a href="#文档类型（在-6-0-0-及以上废弃）" class="headerlink" title="文档类型（在 6.0.0 及以上废弃）"></a>文档类型（在 6.0.0 及以上废弃）</h4><blockquote><p>在ES中，一个索引对象可以存储很多不同用途的对象。</p></blockquote><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><blockquote><p>存储有关字段的信息，每一个文档类型都有自己的映射。</p></blockquote><h4 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h4><blockquote><p>在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。</p><p>也许有一天你想把这些对象存储在数据库中。使用关系型数据库的行和列存储，这相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构–通常一个字段&gt;对应一列–而且又不得不在每次查询时重新构造对象。</p></blockquote><blockquote><p>Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档_。Elasticsearch 不仅存储文档，而且 _索引 每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤–而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p></blockquote><h4 id="分片-Shards"><a href="#分片-Shards" class="headerlink" title="分片(Shards)"></a>分片(Shards)</h4><blockquote><p>索引可能存储大量可能超过单个节点的硬件限制的数据。例如，占用1TB磁盘空间的十亿个文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独从单个节点提供搜索请求。</p><p>为了解决这个问题，Elasticsearch 提供了将索引细分为多个称为分片的功能。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。</p></blockquote><blockquote><p>设置分片的目的及原因主要是：</p><p>它允许您水平拆分/缩放内容量<br>它允许您跨分片（可能在多个节点上）分布和并行化操作，从而提高性能/吞吐量<br>分片的分布方式以及如何将其文档聚合回搜索请求的机制完全由 Elasticsearch 管理，对用户而言是透明的。</p><p>在可能随时发生故障的网络/云环境中，分片非常有用，建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch 允许您将索引的分片的一个或多个副本制作成所谓的副本分片或简称副本。</p></blockquote><h4 id="副本-Replicasedit"><a href="#副本-Replicasedit" class="headerlink" title="副本(Replicasedit)"></a>副本(Replicasedit)</h4><blockquote><p>副本，是对分片的复制。目的是为了当分片/节点发生故障时提供高可用性，它允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。</p><p>总而言之，每个索引可以拆分为多个分片。索引也可以复制为零次（表示没有副本）或更多次。复制之后，每个索引将具有主分片(从原始分片复制而来的)和复制分片(主分片的副本)。</p></blockquote><p><strong>副本是乘法，越多越浪费，但也越保险。分片是除法，分片越多，单分片数据就越少也越分散。</strong></p><p>一个对比图来类比传统关系型数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库   -&gt; Databases(库) -&gt; Tables(表)  -&gt; Rows(行)         -&gt; Columns(列)。</span><br><span class="line">Elasticsearch -&gt; Indeces(索引) -&gt; Types(类型) -&gt; Documents(文档) -&gt; Fields(属性)。</span><br></pre></td></tr></table></figure></p><h2 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h2><p>目前与 elasticsearch 交互主要有两种方式：Client API 和 RESTful API。</p><p>Client API方式：</p><p>Elasticsearch 为以下语言提供了官方客户端 –Groovy、JavaScript、.NET、 PHP、 Perl、 Python 和 Ruby–还有很多社区提供的客户端和插件，所有这些都可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" target="_blank" rel="noopener">Elasticsearch Clients</a> 中找到。</p><p>RESTful API with JSON over HTTP：</p><p>所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 curl 命令来和 Elasticsearch 交互。</p><p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span> -d <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>VERB</td><td>适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE</td></tr><tr><td>PROTOCOL</td><td>http 或者 https（如果你在 Elasticsearch 前面有一个https 代理）</td></tr><tr><td>HOST</td><td>Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点</td></tr><tr><td>PORT</td><td>运行 Elasticsearch HTTP 服务的端口号，默认是 9200</td></tr><tr><td>PATH</td><td>API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm</td></tr><tr><td>QUERY_STRING</td><td>任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</td></tr><tr><td>BODY</td><td>一个 JSON 格式的请求体 (如果请求需要的话)</td></tr></tbody></table><p><strong>常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/brand/_search?pretty=true'</span>         <span class="comment"># 查询索引数据</span></span><br><span class="line">curl -XPUT <span class="string">'localhost:9200/customer?pretty'</span>             <span class="comment"># 创建索引</span></span><br><span class="line">curl -XDELETE <span class="string">'localhost:9200/customer'</span>                 <span class="comment"># 删除索引</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/health?v'</span>                     <span class="comment"># 检测集群是否健康</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/nodes?v'</span>                      <span class="comment"># 获取集群节点</span></span><br><span class="line">curl <span class="string">'localhost:9200/_cat/indices?v'</span>                    <span class="comment"># 列出所有索引</span></span><br><span class="line">curl -x GET <span class="string">'localhost:9200/index/_mapping'</span>             <span class="comment"># 查询指定索引的映射</span></span><br><span class="line">curl -X GET <span class="string">'localhost:9200/_cluster/health?pretty'</span>     <span class="comment"># 查看分片状态</span></span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ol><li>创建第一个简单索引</li></ol><p>创建一个 NBA 球队的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT nba</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>: 3,   </span><br><span class="line">    <span class="string">"number_of_replicas"</span>: 1 </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"mappings"</span>:&#123;</span><br><span class="line">    <span class="string">"nba"</span>:&#123;</span><br><span class="line">      <span class="string">"properties"</span>:&#123;</span><br><span class="line">        <span class="string">"name_cn"</span>:&#123; </span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"name_en"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"gymnasium"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"topStar"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"championship"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"integer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"date"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"date"</span>,</span><br><span class="line">          <span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss|| yyy-MM-dd||epoch_millis"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>字段名称</th><th>字段说明</th></tr></thead><tbody><tr><td>nba</td><td>索引</td></tr><tr><td>number_of_shards</td><td>分片数</td></tr><tr><td>number_of_replicas</td><td>副本数</td></tr><tr><td>name_cn</td><td>球队中文名</td></tr><tr><td>name_en</td><td>球队英文名</td></tr><tr><td>gymnasium</td><td>球馆名称</td></tr><tr><td>championship</td><td>总冠军次数</td></tr><tr><td>topStar</td><td>当家球星</td></tr><tr><td>date</td><td>加入NBA年份</td></tr></tbody></table><p>创建成功则返回信息:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"acknowledged"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"shards_acknowledged"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"index"</span>: <span class="string">"nba"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>新增索引数据</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">PUT /nba/nba/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"San Antonio Spurs SAS"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"圣安东尼安马刺"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"AT&amp;T中心球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"蒂姆·邓肯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1995-04-12"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Los Angeles Lakers"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"洛杉矶湖人"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"斯台普斯中心球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"科比·布莱恩特"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1947-05-12"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Golden State Warriors"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"金州勇士队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"甲骨文球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1949-06-13"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Miami Heat"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"迈阿密热火队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"美国航空球场"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"勒布朗·詹姆斯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1988-06-13"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /nba/nba/5</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name_en"</span>:<span class="string">"Cleveland Cavaliers"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>:<span class="string">"克利夫兰骑士队"</span>,</span><br><span class="line">  <span class="attr">"gymnasium"</span>:<span class="string">"速贷球馆"</span>,</span><br><span class="line">  <span class="attr">"championship"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"topStar"</span>:<span class="string">"勒布朗·詹姆斯"</span>,</span><br><span class="line">  <span class="attr">"date"</span>:<span class="string">"1970-06-13"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>查询全部球队的信息</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应结果:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Los Angeles Lakers"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"洛杉矶湖人"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"斯台普斯中心球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"科比·布莱恩特"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1947-05-12"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"San Antonio Spurs SAS"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"圣安东尼安马刺"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"AT&amp;T中心球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"蒂姆·邓肯"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1995-04-12"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"金州勇士队"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"甲骨文球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1949-06-13"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应的数据结果分为两部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">----------------first part--------------------</span><br><span class="line">  "took": 0,</span><br><span class="line">  "timed_out": false,</span><br><span class="line">  "_shards": &#123;</span><br><span class="line">    "total": 3,</span><br><span class="line">    "successful": 3,</span><br><span class="line">    "skipped": 0,</span><br><span class="line">    "failed": 0</span><br><span class="line">  &#125;,</span><br><span class="line">---------------second part---------------------</span><br><span class="line">  "hits": &#123;</span><br><span class="line">    "total": 0,</span><br><span class="line">    "max_score": null,</span><br><span class="line">    "hits": []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分为：分片副本信息，第二部分 hits 包装的为查询的数据集。</p><ol start="4"><li>查询英文名称为：”Golden State Warriors” 的球队信息</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可得到的查询结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1.9646256</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"nba"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1.9646256</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name_en"</span>: <span class="string">"Golden State Warriors"</span>,</span><br><span class="line">          <span class="attr">"name_cn"</span>: <span class="string">"金州勇士队"</span>,</span><br><span class="line">          <span class="attr">"gymnasium"</span>: <span class="string">"甲骨文球馆"</span>,</span><br><span class="line">          <span class="attr">"championship"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"斯蒂芬·库里"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"1949-06-13"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>过滤查询 Filter</li></ol><p>我们让搜索变的复杂一些。我们想要找到当家球星是勒布朗·詹姆斯，但是我们只想得到总冠军多于1次的球队。我们的语句将做一些改变用来添加过滤器(filter),它允许我们有效的执行一个结构化搜索</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST /nba/nba/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">          <span class="attr">"championship"</span>: &#123;</span><br><span class="line">            <span class="attr">"gt"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"topStar"</span>: <span class="string">"勒布朗·詹姆斯"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现每次查询，查询结果里面都有一个 _score字段，一般Elasticsearch根据相关评分排序，相关评分是根据文档与语句的匹配度来得出， _score值越高说明匹配度越高。</p><p><strong>查询命令</strong></p><ol><li>query_string语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>分页查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "from" : 1,</span></span><br><span class="line"><span class="string">    "size" : 1,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>增加version值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "from" : 1,</span></span><br><span class="line"><span class="string">    "size" : 1,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>限制得分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="5"><li>选择要返回的字段</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "fields" : ["brandName","spuName"],</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><ol start="6"><li>选择要返回的字段</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/product/spu/_search?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "fields" : ["brandName","spuName"],</span></span><br><span class="line"><span class="string">    "version" : true,</span></span><br><span class="line"><span class="string">    "min_score" : 2.4,</span></span><br><span class="line"><span class="string">    "query" : &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;"query" : "brandName:本田"&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot与Elasticsearch集成"><a href="#SpringBoot与Elasticsearch集成" class="headerlink" title="SpringBoot与Elasticsearch集成"></a>SpringBoot与Elasticsearch集成</h2><ol><li>pom文件中添加添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 解决es no jna warning--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>application.yml添加配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    data:</span></span><br><span class="line"><span class="attr">        elasticsearch:</span></span><br><span class="line"><span class="attr">            cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：elasticsearch jar版本要与安装的服务版本相容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch简介&quot;&gt;&lt;a href=&quot;#Elasticsearch简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch简介&quot;&gt;&lt;/a&gt;Elasticsearch简介&lt;/h2&gt;&lt;p&gt;Elasticsearch是一个高度
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://huleski.github.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://huleski.github.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装RabbitMQ</title>
    <link href="http://huleski.github.com/2019/04/22/CentOS7%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>http://huleski.github.com/2019/04/22/CentOS7安装RabbitMQ/</id>
    <published>2019-04-22T01:26:36.000Z</published>
    <updated>2019-04-22T01:32:18.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装ErLang"><a href="#安装ErLang" class="headerlink" title="安装ErLang"></a>安装ErLang</h2><p>rabbitmq依赖于erlang, 因此要<strong>先安装erlang</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget  http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span><br><span class="line">rpm -Uvh erlang-solutions-1.0-1.noarch.rpm</span><br><span class="line">yum install erlang</span><br></pre></td></tr></table></figure><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.14/rabbitmq-server-3.7.14-1.el7.noarch.rpm</span><br><span class="line">yum -y install rabbitmq-server-3.7.14-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server             <span class="comment"># 启动RabbitMQ</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server            <span class="comment"># 开机自启动RabbitMQ</span></span><br><span class="line">systemctl status rabbitmq-server            <span class="comment"># 查看状态</span></span><br></pre></td></tr></table></figure><h2 id="访问web控制台"><a href="#访问web控制台" class="headerlink" title="访问web控制台"></a>访问web控制台</h2><p>初始帐号和密码都为：guest, 但是只能本地登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq-management                 <span class="comment"># 启动RabbitMQ Web管理控制台</span></span><br><span class="line">chown -R rabbitmq:rabbitmq /var/lib/rabbitmq/               <span class="comment"># 将RabbitMQ文件的所有权提供给RabbitMQ用户</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user admin 123456                           <span class="comment"># 为RabbitMQ Web管理控制台创建管理用户</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator               <span class="comment"># 为admin设置管理员角色</span></span><br><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span>       <span class="comment"># 为admin设置默认vhost（“/”）配置、写、读全部权限</span></span><br></pre></td></tr></table></figure><p>访问: <code>http://RabbitMQ_IP:15672/</code> 就能看到RabbitMQ管理页面</p><h2 id="角色说明"><a href="#角色说明" class="headerlink" title="角色说明"></a>角色说明</h2><ul><li><p>超级管理员(administrator)</p><p>  可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p></li><li><p>监控者(monitoring)</p><p>  可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p></li><li><p>策略制定者(policymaker)</p><p>  可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p></li><li><p>普通管理者(management)</p><p>  仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p></li><li><p>其他</p><p>  无法登陆管理控制台，通常就是普通的生产者和消费者。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装ErLang&quot;&gt;&lt;a href=&quot;#安装ErLang&quot; class=&quot;headerlink&quot; title=&quot;安装ErLang&quot;&gt;&lt;/a&gt;安装ErLang&lt;/h2&gt;&lt;p&gt;rabbitmq依赖于erlang, 因此要&lt;strong&gt;先安装erlang&lt;/stron
      
    
    </summary>
    
      <category term="CentOS7" scheme="http://huleski.github.com/categories/CentOS7/"/>
    
    
      <category term="CentOS7" scheme="http://huleski.github.com/tags/CentOS7/"/>
    
      <category term="RabbitMQ" scheme="http://huleski.github.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门教程</title>
    <link href="http://huleski.github.com/2019/04/19/RabbitMQ%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://huleski.github.com/2019/04/19/RabbitMQ入门教程/</id>
    <published>2019-04-19T02:25:59.000Z</published>
    <updated>2019-07-09T07:36:45.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h2><p>RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。</p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>MQ 全称为Message Queue, 消息队列。是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><p>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的要求。<br>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><h2 id="RabbitMQ-应用场景"><a href="#RabbitMQ-应用场景" class="headerlink" title="RabbitMQ 应用场景"></a>RabbitMQ 应用场景</h2><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：</p><blockquote><p>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？</p><p>2）如何降低发送者和接收者的耦合度？</p><p>3）如何让Priority高的接收者先接到数据？</p><p>4）如何做到load balance？有效均衡接收者的负载？</p><p>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</p><p>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</p><p>7）如何保证接收者接收到了完整，正确的数据？</p></blockquote><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-b22270d646a5aeef.jpg" alt="Rabbitmq"></p><h2 id="RabbitMQ使用流程"><a href="#RabbitMQ使用流程" class="headerlink" title="RabbitMQ使用流程"></a>RabbitMQ使用流程</h2><p>AMQP模型中，消息在producer中产生，发送到MQ的exchange上，exchange根据配置的路由方式发到相应的Queue上，Queue又将消息发送给consumer，消息从queue到consumer有push和pull两种方式。 消息队列的使用过程大概如下：</p><ol><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ol><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。 exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。</p><p><strong>RabbitMQ的安装</strong> : 查看下一篇文章</p><h2 id="Java入门实例-Helloworld"><a href="#Java入门实例-Helloworld" class="headerlink" title="Java入门实例(Helloworld)"></a>Java入门实例(Helloworld)</h2><p>一个producer发送消息，一个接收者接收消息，并在控制台打印出来。</p><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-71798beda1e4057.jpg" alt="mq消费过程"></p><p><strong>Java客户端配置</strong></p><p>加入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>发送端</strong>：Send.java 连接到RabbitMQ（此时服务需要启动），发送一条数据，然后退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"helloMQ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> java.io.IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建连接连接到MabbitMQ</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置MabbitMQ所在主机ip或者主机名</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//指定一个队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//发送的消息</span></span><br><span class="line">        String message = <span class="string">"hello world!"</span>;</span><br><span class="line">        <span class="comment">//往队列中发出一条消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是队列只会在它不存在的时候创建，多次声明并不会重复创建。信息的内容是字节数组，也就意味着你可以传递任何数据。</p><p><strong>接收端</strong>：Recv.java 不断等待服务器推送消息，然后在控制台输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"helloMQ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 打开连接和创建频道，与发送端一样</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ工作队列-Work-Queues（Java实例）"><a href="#RabbitMQ工作队列-Work-Queues（Java实例）" class="headerlink" title="RabbitMQ工作队列-Work Queues（Java实例）"></a>RabbitMQ工作队列-Work Queues（Java实例）</h2><p>创建一个工作队列用来在工作者（consumer）间分发耗时任务。</p><p><img src="http://pubgmjp23.bkt.clouddn.com/683118-1153d8d6c2a8d9a3.jpg" alt="RabbitMQ工作队列"></p><p>工作队列的主要任务是：避免立刻执行资源密集型任务，然后必须等待其完成。相反地，我们进行任务调度：我们把任务封装为消息发送给队列。工作进行在后台运行并不断的从队列中取出任务然后执行。当你运行了多个工作进程时，任务队列中的任务将会被工作进程共享执行。</p><p>我们使用Thread.sleep来模拟耗时的任务, 然后启动两个work, 可以发现<code>消费时间变短</code>了</p><p><strong>发送端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        String message = String.valueOf(System.currentTimeMillis());</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">final</span> Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep( <span class="number">5000</span>);    <span class="comment">// 执行耗时操作</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">" [x] Done"</span> + message);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用任务队列的好处是能够很容易的并行工作。如果我们积压了很多工作，我们仅仅通过增加更多的工作者就可以解决问题，使系统的伸缩性更加容易。</p><p><strong>消息确认</strong><br>执行一个任务需要花费几秒钟。你可能会担心当一个工作者在执行任务时发生中断。我们上面的代码，一旦RabbItMQ交付了一个信息给消费者，会马上从内存中移除这个信息。在这种情况下，如果杀死正在执行任务的某个工作者，我们会丢失它正在处理的信息。我们也会丢失已经转发给这个工作者且它还未执行的消息。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span> ; <span class="comment">//打开消息应答机制  </span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, ack, consumer);  </span><br><span class="line"><span class="comment">//另外需要在每次处理完成一个消息后，手动发送一次应答。  </span></span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><strong>消息的持久性</strong></p><p>虽然消费者被杀死，消息也不会被丢失。但是如果此时RabbitMQ服务被停止，我们的消息仍然会丢失。<br>当RabbitMQ退出或者异常退出，将会丢失所有的队列和信息，除非你告诉它不要丢失。我们需要做两件事来确保信息不会被丢失：我们需要给所有的队列和消息设置持久化的标志。</p><p>第一， 我们需要确认RabbitMQ永远不会丢失我们的队列。为了这样，我们需要声明它为持久化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"task_queue"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注：RabbitMQ不允许使用不同的参数重新定义一个队列，所以已经存在的队列，我们无法修改其属性。</p><p>第二， 我们需要标识我们的信息为持久化的。通过设置MessageProperties（implements BasicProperties）值为<code>PERSISTENT_TEXT_PLAIN</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"task_queue"</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br></pre></td></tr></table></figure><p>现在你可以执行一个发送消息的程序，然后关闭服务，再重新启动服务，运行消费者程序测试。</p><p><strong>公平的分配</strong></p><p>或许会发现，目前的消息转发机制（Round-robin）并非是我们想要的。例如，这样一种情况，对于两个消费者，有一系列的任务，奇数任务特别耗时，而偶数任务却很轻松，这样造成一个消费者一直繁忙，另一个消费者却很快执行完任务后等待。<br>造成这样的原因是因为RabbitMQ仅仅是当消息到达队列进行转发消息。并不在乎有多少任务消费者并未传递一个应答给RabbitMQ。仅仅盲目转发所有的奇数给一个消费者，偶数给另一个消费者。</p><p>为了解决这样的问题，我们可以使用basicQos方法，传递参数为prefetchCount = 1。这样告诉RabbitMQ不要在同一时间给一个消费者超过一条消息。换句话说，只有在消费者空闲的时候会发送下一条信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;  </span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h2 id="Exchange-的几种模式"><a href="#Exchange-的几种模式" class="headerlink" title="Exchange 的几种模式"></a>Exchange 的几种模式</h2><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种，分别有以下一些属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name：名称</span><br><span class="line">Durability：持久化标志，如果为true，则表明此exchange是持久化的。</span><br><span class="line">Auto-delete：删除标志，当所有队列在完成使用此exchange时，是否删除</span><br></pre></td></tr></table></figure><p><strong>1、fanout类型</strong></p><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到fanout Exchange的消息都会被转发到与该Exchange 绑定(Binding)的所有Queue上。</p><p>Fanout Exchange  不需要处理RouteKey 。只需要简单的将队列绑定到exchange 上。这样发送到exchange的消息都会被转发到与该交换机绑定的所有队列上。类似子网广播，每台子网内的主机都获得了一份复制的消息。所以，Fanout Exchange 转发消息是最快的。</p><p><strong>2、direct类型</strong></p><p>direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</p><p>direct Exchange是RabbitMQ Broker的<code>默认Exchange</code>，它有一个特别的属性对一些简单的应用来说是非常有用的，在使用这个类型的Exchange时，可以不必指定routing key的名字，在此类型下创建的Queue有一个默认的routing key，这个routing key一般同Queue同名。</p><p>direct模式,可以使用rabbitMQ自带的Exchange：default Exchange 。所以不需要将Exchange进行任何绑定(binding)操作 。消息传递时，RouteKey必须完全匹配，才会被队列接收，否则该消息会被抛弃。</p><p><strong>3、topic类型</strong></p><p>topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p><blockquote><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</p><p>binding key与routing key一样也是句点号“. ”分隔的字符串</p><p>binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</p></blockquote><p>所有发送到Topic Exchange的消息被转发到所有关心RouteKey中指定Topic的Queue上，Exchange 将RouteKey 和某Topic 进行模糊匹配。此时队列需要绑定一个Topic。可以使用通配符进行模糊匹配，符号“#”匹配一个或多个词，符号“”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.” 只会匹配到“log.error”。</p><p><strong>4、headers类型</strong></p><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</p><p>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ-简介&quot;&gt;&lt;a href=&quot;#RabbitMQ-简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 简介&quot;&gt;&lt;/a&gt;RabbitMQ 简介&lt;/h2&gt;&lt;p&gt;RabbitMQ是一个在AMQP（Advanced Message 
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://huleski.github.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://huleski.github.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>消息队列之JMS和AMQP的关系</title>
    <link href="http://huleski.github.com/2019/04/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BJMS%E5%92%8CAMQP%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://huleski.github.com/2019/04/19/消息队列之JMS和AMQP的关系/</id>
    <published>2019-04-19T01:41:16.000Z</published>
    <updated>2019-07-09T07:41:09.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>通常而言提到JMS（Java MessageService）实际上是指JMS API。JMS是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive等。JMS已经成为Java Enterprise Edition的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了JMS的服务进行通信，进行相关的操作。</p><p>JMS通常包含如下一些角色：<br>Elements    |   Notes<br>———– | ——–<br>JMS provider    |   实现了JMS接口的消息中间件，如ActiveMQ<br>JMS client    |   生产或者消费消息的应用<br>JMS producer/publisher    |   JMS消息生产者<br>JMS consumer/subscriber    |   JMS消息消费者<br>JMS message    |    消息，在各个JMS client传输的对象；<br>JMS queue    |   Provider存放等待被消费的消息的地方<br>JMS topic    |   一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。</p><p> JMS提供了两种消息模型，peer-2-peer(点对点)以及publish-subscribe（发布订阅）模型。当采用点对点模型时，消息将发送到一个队列，该队列的消息只能被一个消费者消费。而采用发布订阅模型时，消息可以被多个消费者消费。在发布订阅模型中，生产者和消费者完全独立，不需要感知对方的存在。</p><p>消息如何从producer端达到consumer端由message-routing来决定。在JMS中，消息路由非常简单，由producer和consumer链接到同一个queue（p2p）或者topic（pub/sub）来实现消息的路由。JMSconsumer同时支持message selector（消息选择器），通过消息选择器，consumer可以只消费那些通过了selector筛选的消息。在JMS兄中，消息路由机制的图示如下：</p><p><img src="http://pubgmjp23.bkt.clouddn.com/20140410230348859.png" alt="消息路由"></p><p>常见的消息队列，大部分都实现了JMS API，可以担任JMS provider的角色，如ActiveMQ，Redis以及RabbitMQ等。</p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。意味着我们可以使用Java的AMQP provider，同时使用一个python的producer加一个rubby的consumer。从这一点看，AQMP可以用http来进行类比，不关心实现的语言，只要大家都按照相应的数据格式去发送报文请求，不同语言的client均可以和不同语言的server链接。</p><p>在AMQP中，消息路由（messagerouting）和JMS存在一些差别，在AMQP中增加了Exchange和binding的角色。producer将消息发送给Exchange，binding决定Exchange的消息应该发送到那个queue，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。AMQP的routing scheme图示过程如下：</p><p><img src="http://pubgmjp23.bkt.clouddn.com/20140410230404281.png" alt="AMQP"></p><p>目前AMQP逐渐成为消息队列的一个标准协议，当前比较流行的rabbitmq、stormmq都使用了AMQP实现。</p><p>JMS和AMQP的各项对比如下：</p><table><thead><tr><th>信息</th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java api</td><td>Wire-protocol</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>Model</td><td>提供两种消息模型：<br>（1）、Peer-2-Peer<br>（2）、Pub/sub</td><td>提供了五种消息模型：<br>（1）、direct exchange<br>（2）、fanout exchange<br>（3）、topic change<br>（4）、headers exchange<br>（5）、system exchange<br>本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td>支持消息类型</td><td>多种消息类型：<br>TextMessage<br>MapMessage<br>BytesMessage<br>StreamMessage<br>ObjectMessage<br>Message （只有消息头和属性）</td><td>byte[]<br>当实际应用时，有复杂的消息，可以将消息序列化后发送。</td></tr><tr><td>综合评价</td><td>JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差；</td><td>AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。</td></tr></tbody></table><p><a href="https://blog.csdn.net/hpttlook/article/details/23391967" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JMS&quot;&gt;&lt;a href=&quot;#JMS&quot; class=&quot;headerlink&quot; title=&quot;JMS&quot;&gt;&lt;/a&gt;JMS&lt;/h2&gt;&lt;p&gt;通常而言提到JMS（Java MessageService）实际上是指JMS API。JMS是由Sun公司早期提出的消息标准，旨在为
      
    
    </summary>
    
      <category term="消息队列" scheme="http://huleski.github.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="http://huleski.github.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装JDK1.8</title>
    <link href="http://huleski.github.com/2019/04/17/CentOS7%E5%AE%89%E8%A3%85JDK1-8/"/>
    <id>http://huleski.github.com/2019/04/17/CentOS7安装JDK1-8/</id>
    <published>2019-04-17T02:07:07.000Z</published>
    <updated>2019-04-17T02:33:33.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看已安装的jdk并卸载"><a href="#查看已安装的jdk并卸载" class="headerlink" title="查看已安装的jdk并卸载"></a>查看已安装的jdk并卸载</h2><p>查询jdk ( 新装的centos会默认安装openjre )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis java</span><br><span class="line"><span class="built_in">which</span> java （java执行路径）</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>确定JDK的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure><p>可能的结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br></pre></td></tr></table></figure><p>卸载jdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64  </span><br><span class="line">yum -y remove java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.htm" target="_blank" rel="noopener">下载地址</a></p><p>将下载好的文件<code>jdk-8u191-linux-x64.tar.gz</code>放在 <code>/data</code> 目录下, 解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>解压成功后，则可以看到jdk1.8.0_191文件夹</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在配置文件末尾添加一下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/data/jdk1.8.0_191</span><br><span class="line">JRE_HOME=/data/jdk1.8.0_191/jre</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><p>保存退出, 是配置文件立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profie</span><br></pre></td></tr></table></figure><p>查看java是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看已安装的jdk并卸载&quot;&gt;&lt;a href=&quot;#查看已安装的jdk并卸载&quot; class=&quot;headerlink&quot; title=&quot;查看已安装的jdk并卸载&quot;&gt;&lt;/a&gt;查看已安装的jdk并卸载&lt;/h2&gt;&lt;p&gt;查询jdk ( 新装的centos会默认安装openjre 
      
    
    </summary>
    
      <category term="CentOS7" scheme="http://huleski.github.com/categories/CentOS7/"/>
    
    
      <category term="CentOS7" scheme="http://huleski.github.com/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机GC详解</title>
    <link href="http://huleski.github.com/2019/04/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://huleski.github.com/2019/04/13/Java虚拟机GC详解/</id>
    <published>2019-04-13T10:39:00.000Z</published>
    <updated>2019-04-22T01:24:20.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-GC的定义和价值"><a href="#1-GC的定义和价值" class="headerlink" title="1. GC的定义和价值"></a>1. GC的定义和价值</h2><p>​    在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止人为的内存泄露。</p><p>　    Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代 码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。</p><p>​    概括地说，该机制对 JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><h2 id="2-思考GC的运行原理"><a href="#2-思考GC的运行原理" class="headerlink" title="2. 思考GC的运行原理"></a>2. 思考GC的运行原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一步：确认那些对象需要回收</span><br><span class="line">第二步：使用什么方法回收</span><br></pre></td></tr></table></figure><h2 id="3-确认哪些对象需要回收"><a href="#3-确认哪些对象需要回收" class="headerlink" title="3. 确认哪些对象需要回收"></a>3. 确认哪些对象需要回收</h2><p>常见的算法有2种：引用计数算法和根搜索算法。</p><ul><li>引用计算法无法解决循环引用问题，java不采用，采用了根搜索算法。</li></ul><h4 id="3-1-引用计数法"><a href="#3-1-引用计数法" class="headerlink" title="3-1 引用计数法"></a>3-1 引用计数法</h4><h6 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3-1-1 概念"></a>3-1-1 概念</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</span><br></pre></td></tr></table></figure><h5 id="3-1-2-特点"><a href="#3-1-2-特点" class="headerlink" title="3-1-2 特点"></a>3-1-2 特点</h5><p>引用计数算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。<br>它很难解决对象之间相互循环引用的问题,对于循环引用的对象无法进行回收</p><ul><li>由于循环引用的计数器都不为0，但是他们对于根对象都已经不可达了，但是无法释放。</li></ul><h4 id="3-2-根搜索算法"><a href="#3-2-根搜索算法" class="headerlink" title="3-2 根搜索算法"></a>3-2 根搜索算法</h4><h4 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3-2-1 概念"></a>3-2-1 概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于引用计数算法的缺陷，所以JVM一般会采用一种新的算法，叫做根搜索算法。它的处理方式就是，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</span><br></pre></td></tr></table></figure><p><img src="/images/jvm_gc/jvm_gc1.webp" alt="Logo"></p><h4 id="3-2-2-特点"><a href="#3-2-2-特点" class="headerlink" title="3-2-2 特点"></a>3-2-2 特点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如上图所示, 由于GC roots到灰色对象部分不可达，所以最终灰色对象部分还是会被当做GC的对象，上图若是采用引用计数法，则灰色对象部分都不会被回收。</span><br></pre></td></tr></table></figure><p>3-2-3 可达性的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 来历</span><br><span class="line">* 我们刚刚提到，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</span><br><span class="line">* 我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调从根节点开始，对所有可达对象做一次标记，那什么叫做可达呢？</span><br><span class="line"></span><br><span class="line">2. 讲解</span><br><span class="line">* 这里解释如下：可达性分析：从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连（用图论的概念来讲，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</span><br><span class="line"></span><br><span class="line">3. jvm常见的根(GC roots)对象</span><br><span class="line">a. 栈（栈帧中的本地变量表）中引用的对象。</span><br><span class="line">b. 方法区中的静态成员。</span><br><span class="line">c. 方法区中的常量引用的对象（全局变量</span><br><span class="line">d. 方法栈中JNI（一般说的Native方法）引用的对象。</span><br><span class="line"></span><br><span class="line">**注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</span><br></pre></td></tr></table></figure><h2 id="4-基础的GC回收算法"><a href="#4-基础的GC回收算法" class="headerlink" title="4. 基础的GC回收算法"></a>4. 基础的GC回收算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。</span><br></pre></td></tr></table></figure><h4 id="4-1-最基础：标记-清除算法"><a href="#4-1-最基础：标记-清除算法" class="headerlink" title="4-1  最基础：标记/清除算法"></a>4-1  最基础：标记/清除算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 介绍</span><br><span class="line">标记/清除算法是几种GC算法中最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</span><br><span class="line"></span><br><span class="line">2. 原理</span><br><span class="line">* 标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</span><br><span class="line"></span><br><span class="line">* 标记阶段：标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象；</span><br><span class="line"></span><br><span class="line">* 清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收。</span><br><span class="line"></span><br><span class="line">3. 具体的算法过程</span><br><span class="line">* 在标记阶段，从对象GC Root 1可以访问到B对象，从B对象又可以访问到E对象，因此从GC Root 1到B、E都是可达的，同理，对象F、G、J、K都是可达对象；到了清除阶段，所有不可达对象都会被回收。</span><br><span class="line"></span><br><span class="line">* 在垃圾收集器进行GC时，必须停止所有Java执行线程（也称&quot;STW, Stop The World&quot;），原因是在标记阶段进行可达性分析时，不可以出现分析过程中对象引用关系还在不断变化的情况，否则的话可达性分析结果的准确性就无法得到保证。在等待标记清除结束后，应用线程才会恢复运行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存在的缺陷:</span><br><span class="line">1、效率问题。标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。</span><br><span class="line">2、空间问题。标记清除之后会产生大量不连续的内存碎片（从上图可以看出），内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</span><br><span class="line"></span><br><span class="line">* 内存碎片的影响</span><br></pre></td></tr></table></figure><h4 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4-2 复制算法"></a>4-2 复制算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原理</span><br><span class="line">* 复制算法为了解决效率问题，复制算法出现了。复制算法的原理是：将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉。</span><br><span class="line"></span><br><span class="line">2. 具体的算法过程</span><br><span class="line">* 复制算法每次都是对整个半区进行内存回收，这样就减少了标记对象遍历的时间，在清除使用区域对象时，不用进行遍历，直接清空整个区域内存，而且在将存活对象复制到保留区域时也是按地址顺序存储的，这样就解决了内存碎片的问题，在分配对象内存时不用考虑内存碎片等复杂问题，只需要按顺序分配内存即可。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 优缺点</span><br><span class="line">* 复制算法简单高效，优化了标记/清除算法的效率低、内存碎片多的问题。</span><br><span class="line">* 缺点也很明显：</span><br><span class="line">a. 将内存缩小为原来的一半，浪费了一半的内存空间，代价太高</span><br><span class="line">b. 如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍，耗费的时间代价也是不可忽视的。</span><br></pre></td></tr></table></figure><h4 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4-3 标记/整理算法"></a>4-3 标记/整理算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原理</span><br><span class="line">    从名字上看，这种算法与标记/清除算法很像，事实上，标记/整理算法的标记过程任然与标记/清除算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。</span><br><span class="line"></span><br><span class="line">2. 算法分析</span><br><span class="line">    回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。这样一来，当我们给新对象分配内存时，jvm只需要持有内存的起始地址即可。标记/整理算法不仅弥补了标记/清除算法存在内存碎片的问题，也消除了复制算法内存减半的高额代价，可谓一举两得。但任何算法都有缺点，就像人无完人，标记/整理算法的缺点就是效率也不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。</span><br></pre></td></tr></table></figure><h4 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4-4 总结"></a>4-4 总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 弄清了以上三种算法的原理，下面我们来从几个方面对这几种算法做一个简单排行。</span><br><span class="line"></span><br><span class="line">效率：复制算法 &gt; 标记/整理算法 &gt; 标记/清除算法（标记/清除算法有内存碎片问题，给大对象分配内存时可能会触发新一轮垃圾回收）</span><br><span class="line">内存整齐率：复制算法 = 标记/整理算法 &gt; 标记/清除算法</span><br><span class="line">内存利用率：标记/整理算法 = 标记/清除算法 &gt; 复制算法</span><br><span class="line"></span><br><span class="line">从上面简单的评估可以看出，标记/清除算法已经比较落后了，但是吃水不忘挖井人，它是后面几种算法的前辈、是基础，在某些场景下它也有用武之地。</span><br></pre></td></tr></table></figure><h2 id="5-JVM采用的GC回收算法：分代回收算法"><a href="#5-JVM采用的GC回收算法：分代回收算法" class="headerlink" title="5.  JVM采用的GC回收算法：分代回收算法"></a>5.  JVM采用的GC回收算法：分代回收算法</h2><h4 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5-1 概念"></a>5-1 概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 引言</span><br><span class="line">* 通过上面的分析，每种算法都有各自的特点，没有完美的解决方案。所以，JVM虚拟机，根据自身的特点，设计了一个特别的GC回收机制： 分代回收算法。</span><br><span class="line"></span><br><span class="line">2. 分代回收算法概念</span><br><span class="line">* 根据对象的存活周期的不同，将内存划分为几块儿。</span><br><span class="line">* Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。</span><br></pre></td></tr></table></figure><h4 id="5-2-原理"><a href="#5-2-原理" class="headerlink" title="5-2 原理"></a>5-2 原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分代回收算法原理</span><br><span class="line">a. 少量对象存活，适合复制算法：</span><br><span class="line">* 在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。</span><br><span class="line"></span><br><span class="line">b. 大量对象存活，适合用标记-清理/标记-整理：</span><br><span class="line">* 在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。</span><br></pre></td></tr></table></figure><h4 id="5-3-新生代和老年代对象的来历"><a href="#5-3-新生代和老年代对象的来历" class="headerlink" title="5-3 新生代和老年代对象的来历"></a>5-3 新生代和老年代对象的来历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a. 所有第一次分配的对象，都是新生代。</span><br><span class="line">b. 新生代的内存满后，启动GC，大概98%的对象会被回收，2%的对象，会存活下来。每经历一次GC，对象的年龄增长1岁。</span><br><span class="line">c. 当年龄达到阀值（默认是15，可设定），即经历了15次GC，仍然活着，就从新生代转移到老年代。</span><br><span class="line"></span><br><span class="line">d. 老年代还有来历特别的对象：新生代进行垃圾回收时，某个对象特别大，可能无需等到15岁，就直接进入老年代</span><br></pre></td></tr></table></figure><h4 id="5-3-新生代的回收策略"><a href="#5-3-新生代的回收策略" class="headerlink" title="5-3 新生代的回收策略"></a>5-3 新生代的回收策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 新生代的特点</span><br><span class="line">* 新生代中的对象几乎都是“朝生夕死”的（达到98%，即98%的对象活不过1岁）</span><br><span class="line"></span><br><span class="line">2. 选择复制算法的原因分析</span><br><span class="line">* 复制算法的效率最高，但是浪费50%的内存。</span><br><span class="line">* 但是新生代的对象存活率低，所以并不需要按照1：1的比例来划分内存空间</span><br><span class="line">* 而是将内存分为一块较大的Eden空间和两块较小的Survivor1空间、Survivor2空间，三者的比例为8：1：1。</span><br><span class="line"></span><br><span class="line">3. 算法的实现</span><br><span class="line">* 将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。</span><br><span class="line">* 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</span><br><span class="line">* 默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</span><br><span class="line">* 98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</span><br></pre></td></tr></table></figure><h4 id="5-4-GC分类"><a href="#5-4-GC分类" class="headerlink" title="5-4 GC分类"></a>5-4 GC分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Minor GC：只有新生代进行GC，发生频繁，但是，STW(stop the world)的时间短。</span><br><span class="line">Major GC: 年长代进行GC, 因年长代空间比新生代大，故运行次数少，其一般采用“标记-清理”/“标记-整理”，STW的时间长。</span><br><span class="line">FULL GC: 新生代和年老代，都进行GC操作。所需时间最长，STW最长。</span><br></pre></td></tr></table></figure><h4 id="5-5-STW-Stop-The-World"><a href="#5-5-STW-Stop-The-World" class="headerlink" title="5-5 STW(Stop-The-World)"></a>5-5 STW(Stop-The-World)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 概念</span><br><span class="line">* Java中一种全局暂停的现象。全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互多半情况下是由于GC引起。</span><br><span class="line"></span><br><span class="line">2. GC引起STW的原因</span><br><span class="line">* 打个比方：类比在聚会，突然GC要过来打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。况且，如果没有全局停顿，会给GC线程造成很大的负担，GC算法的难度也会增加，GC很难去判断哪些是垃圾。</span><br><span class="line"></span><br><span class="line">3. 危害</span><br><span class="line">* 长时间服务停止，没有响应</span><br></pre></td></tr></table></figure><h2 id="JVM-GC-垃圾回收器类型"><a href="#JVM-GC-垃圾回收器类型" class="headerlink" title="JVM GC 垃圾回收器类型"></a>JVM GC 垃圾回收器类型</h2><p>JVM的垃圾回收器大致分为四种类型：<br><img src="/images/jvm_gc/jvm_gc2.jpg" alt="jvm类型"></p><p><strong>1、串行垃圾回收器  Serial Garbage Collector</strong></p><p>串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作。<br>串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。（一般是command line程序）<br>使用方法：-XX:+UseSerialGC<br>Ps：在jdk client模式，不指定VM参数，默认是串行垃圾回收器</p><p><img src="/images/jvm_gc/jvm_gc3.jpg" alt="串行垃圾回收器"></p><p><strong>2、并行垃圾回收器  Parallel Garbage Collector</strong></p><p>并行垃圾回收器在进行垃圾回收时，同样会持有所有应用程序的线程，并冻结所有应用程序线程，来进行垃圾回收工作。<br>唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。</p><p><img src="/images/jvm_gc/jvm_gc4.jpg" alt="并行垃圾回收器"></p><p><strong>3、并发标记扫描垃圾回收器 CMS Garbage Collector</strong></p><p>Concurrent Mark Sweep (CMS)垃圾回收器使用并发标记算法，使用多线程来扫描heap memory来标记实例，然后清理被标记过的实例。<br>CMS垃圾回收器有时候会Hold所有的应用程序线程，但有时候只会Hold部分应用程序线程。</p><p>如果能分配更多的CPU给垃圾回收器，那么CMS会是一个比并行垃圾回收更好的选择。XX:+USeParNewGC</p><p><img src="/images/jvm_gc/jvm_gc5.jpg" alt="并发标记扫描垃圾回收器"></p><p><strong>4、G1垃圾回收器  G1 Garbage Collector</strong></p><p>G1垃圾回收器是用在heap memory很大的情况下，把heap划分为很多很多的region块，然后并行的对其进行垃圾回收。<br>G1垃圾回收器在清除实例所占用的内存空间后，还会做内存压缩。</p><p>G1垃圾回收器回收region的时候基本不会STW，而是基于 most garbage优先回收 的策略来对region进行垃圾回收的。</p><p>–XX:+UseG1GC</p><p>java8中，使用-XX:+UseStringDeduplication。这个优化会优化冗余的string为一个char数组。</p><p><img src="/images/jvm_gc/jvm_gc6.jpg" alt="G1垃圾回收器"></p><p>查看JVM使用的默认的垃圾收集器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><h2 id="jvm配置"><a href="#jvm配置" class="headerlink" title="jvm配置"></a>jvm配置</h2><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>Serial Garbage Collector 串行垃圾回收器</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel Garbage Collector并行垃圾回收器</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>CMS Garbage Collector并发标记垃圾回收器</td></tr><tr><td>-XX:ParallelCMSThreads=</td><td>CMS Collector – number of threads to use 并发标记垃圾回收器使用的线程数，通常是cpu个数</td></tr><tr><td>-XX:+UseG1GC</td><td>G1 Gargbage Collector 使用G1垃圾回收器</td></tr></tbody></table><p>优化选项</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-Xms</td><td>Initial heap memory size 初始化heap大小 -Xms512M</td></tr><tr><td>-Xmx</td><td>Maximum heap memory size 设置最大的heap大小</td></tr><tr><td>-Xmn</td><td>Size of Young Generation 年轻代的大小</td></tr><tr><td>-XX:PermSize</td><td>Initial Permanent Generation size 初始化永久带的大小</td></tr><tr><td>-XX:MaxPermSize</td><td>Maximum Permanent Generation size 最大的永久带大小</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>垃圾回收器目前分为四种类型, 串行，并行，并发标记，G1。</p><p>小数据量和小型应用，使用串行垃圾回收器即可。</p><p>对于对响应时间无特殊要求的，可以使用并行垃圾回收器和并发标记垃圾回收器。（中大型应用）</p><p>对于heap可以分配很大的中大型应用，使用G1垃圾回收器比较好，进一步优化和减少了GC暂停时间。</p><p>没有银弹，针对不同的场景，选用不同的垃圾回收器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-GC的定义和价值&quot;&gt;&lt;a href=&quot;#1-GC的定义和价值&quot; class=&quot;headerlink&quot; title=&quot;1. GC的定义和价值&quot;&gt;&lt;/a&gt;1. GC的定义和价值&lt;/h2&gt;&lt;p&gt;​    在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没
      
    
    </summary>
    
      <category term="java" scheme="http://huleski.github.com/categories/java/"/>
    
    
      <category term="java" scheme="http://huleski.github.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java Future模式详解</title>
    <link href="http://huleski.github.com/2019/04/04/java-Future%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://huleski.github.com/2019/04/04/java-Future模式详解/</id>
    <published>2019-04-04T01:22:02.000Z</published>
    <updated>2019-04-15T12:39:34.397Z</updated>
    
    <content type="html"><![CDATA[<p>假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p><p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p><p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。</p><p>模拟代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonCook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 第一步 网购厨具</span></span><br><span class="line">        OnlineShopping thread = <span class="keyword">new</span> OnlineShopping();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();  <span class="comment">// 保证厨具送到</span></span><br><span class="line">        <span class="comment">// 第二步 去超市购买食材</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟购买食材时间</span></span><br><span class="line">        Shicai shicai = <span class="keyword">new</span> Shicai();</span><br><span class="line">        System.out.println(<span class="string">"第二步：食材到位"</span>);</span><br><span class="line">        <span class="comment">// 第三步 用厨具烹饪食材</span></span><br><span class="line">        System.out.println(<span class="string">"第三步：开始展现厨艺"</span>);</span><br><span class="line">        cook(thread.chuju, shicai);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"总共用时"</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 网购厨具线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineShopping</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Chuju chuju;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"第一步：下单"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第一步：等待送货"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);  <span class="comment">// 模拟送货时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第一步：快递送到"</span>);</span><br><span class="line">            chuju = <span class="keyword">new</span> Chuju();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  用厨具烹饪食材</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">(Chuju chuju, Shicai shicai)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 厨具类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chuju</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 食材类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shicai</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第一步：快递送到</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：开始展现厨艺</span><br><span class="line">总共用时7013ms</span><br></pre></td></tr></table></figure><p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p><p>那如果不阻塞呢?这是不行的, 因为run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，做不了饭。</p><p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p><p>如果想在子线程run方法计算的期间，主线程继续异步执行呢?这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p><p>模拟代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 第一步 网购厨具</span></span><br><span class="line">        Callable&lt;Chuju&gt; onlineShopping = <span class="keyword">new</span> Callable&lt;Chuju&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Chuju <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"第一步：下单"</span>);</span><br><span class="line">                System.out.println(<span class="string">"第一步：等待送货"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);  <span class="comment">// 模拟送货时间</span></span><br><span class="line">                System.out.println(<span class="string">"第一步：快递送到"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Chuju();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Chuju&gt; task = <span class="keyword">new</span> FutureTask&lt;Chuju&gt;(onlineShopping);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="comment">// 第二步 去超市购买食材</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟购买食材时间</span></span><br><span class="line">        Shicai shicai = <span class="keyword">new</span> Shicai();</span><br><span class="line">        System.out.println(<span class="string">"第二步：食材到位"</span>);</span><br><span class="line">        <span class="comment">// 第三步 用厨具烹饪食材</span></span><br><span class="line">        <span class="keyword">if</span> (!task.isDone()) &#123;  <span class="comment">// 联系快递员，询问是否到货</span></span><br><span class="line">            System.out.println(<span class="string">"第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Chuju chuju = task.get();</span><br><span class="line">        System.out.println(<span class="string">"第三步：厨具到位，开始展现厨艺"</span>);</span><br><span class="line">        cook(chuju, shicai);</span><br><span class="line">        System.out.println(<span class="string">"总共用时"</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  用厨具烹饪食材</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">(Chuju chuju, Shicai shicai)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 厨具类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chuju</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 食材类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shicai</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）</span><br><span class="line">第一步：快递送到</span><br><span class="line">第三步：厨具到位，开始展现厨艺</span><br><span class="line">总共用时5005ms</span><br></pre></td></tr></table></figure><p>可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p><p>具体分析一下第二段代码：</p><ol><li>把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。</p><ol start="2"><li>把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程。</p><p>这里的控制包括：</p><ul><li>get方法：获取计算结果（如果还没计算完，也是必须等待的）</li><li>cancel方法：还没计算完，可以取消计算过程</li><li>isDone方法：判断是否计算完</li><li>isCancelled方法：判断计算是否被取消</li><li>这些接口的设计很完美，FutureTask的实现注定不会简单，后面再说。</li></ul><ol start="3"><li>在第三步里面，调用了isDone方法查看状态，然后直接调用task.get方法获取厨具，不过这时还没送到，所以还是会等待3秒。对比第一段代码的执行结果，这里我们节省了2秒。这是因为在快递员送货期间，我们去超市购买食材，这两件事在同一时间段内异步执行。</li></ol><p>下面具体分析下FutureTask的实现(JDK8), FutureTask也是一个Runnable，那就看看它的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable; <span class="comment">// 这里的callable是从构造方法里面传人的</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex); <span class="comment">// 保存call方法抛出的异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)   set(result); <span class="comment">// 保存call方法的执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)     handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看try语句块里面的逻辑，发现run方法的主要逻辑就是运行Callable的call方法，然后将保存结果或者异常（用的一个属性result）。这里比较难想到的是，将call方法抛出的异常也保存起来了。</p><p>state属性有以下几个值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>把FutureTask看作一个Future，那么它的作用就是控制Callable的call方法的执行过程，在执行的过程中自然会有状态的转换：</p><ol><li>一个FutureTask新建出来，state就是NEW状态；COMPETING和INTERRUPTING用的进行时，表示瞬时状态，存在时间极短；NORMAL代表顺利完成；EXCEPTIONAL代表执行过程出现异常；CANCELED代表执行过程被取消；INTERRUPTED被中断</li><li>执行过程顺利完成：NEW -&gt; COMPLETING -&gt; NORMAL</li><li>执行过程出现异常：NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</li><li>执行过程被取消：NEW -&gt; CANCELLED</li><li>执行过程中，线程中断：NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li></ol><p>get方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法的逻辑很简单，如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。awaitDone方法里面死循环的逻辑，推演几遍就能弄懂；它里面挂起线程的主要创新是定义了WaitNode类，来将多个等待线程组织成队列，这是与JDK6的实现最大的不同。</p><p>挂起的线程唤醒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t); <span class="comment">// 唤醒线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是JDK8的大体实现逻辑</p><p>JDK6的FutureTask的基本操作都是通过自己的内部类Sync来实现的，而Sync继承自AbstractQueuedSynchronizer这个并发工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** State value representing that task is running */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** State value representing that task ran */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RAN       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** State value representing that task was cancelled */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The underlying callable */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** The result to return from get() */</span></span><br><span class="line"><span class="keyword">private</span> V result;</span><br><span class="line"><span class="comment">/** The exception to throw from get() */</span></span><br><span class="line"><span class="keyword">private</span> Throwable exception;</span><br></pre></td></tr></table></figure><p>里面的状态只有基本的几个，而且计算结果和异常是分开保存的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">innerGet</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    acquireSharedInterruptibly(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (getState() == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个get方法里面处理等待线程队列的方式是调用了acquireSharedInterruptibly方法</p><p>再上一个场景：我们自己写一个简单的数据库连接池，能够复用数据库连接，并且能在高并发情况下正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Connection&gt; pool = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Connection&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pool.containsKey(key)) &#123;</span><br><span class="line">            conn = pool.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn = createConnection();</span><br><span class="line">            pool.putIfAbsent(key, conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Connection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用了ConcurrentHashMap，这样就不必把getConnection方法置为synchronized(当然也可以用Lock)，当多个线程同时调用getConnection方法时，性能大幅提升。</p><p>貌似很完美了，但是有可能导致多余连接的创建，推演一遍：</p><p>某一时刻，同时有3个线程进入getConnection方法，调用pool.containsKey(key)都返回false，然后3个线程各自都创建了连接。虽然ConcurrentHashMap的put方法只会加入其中一个，但还是生成了2个多余的连接。如果是真正的数据库连接，那会造成极大的资源浪费。</p><p>所以，我们现在的难点是：如何在多线程访问getConnection方法时，只执行一次createConnection。</p><p>结合之前Future模式的实现分析：当3个线程都要创建连接的时候，如果只有一个线程执行createConnection方法创建一个连接，其它2个线程只需要用这个连接就行了。再延伸，把createConnection方法放到一个Callable的call方法里面，然后生成FutureTask。我们只需要让一个线程执行FutureTask的run方法，其它的线程只执行get方法就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt; pool = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        FutureTask&lt;Connection&gt; connectionTask = pool.get(key);</span><br><span class="line">        <span class="keyword">if</span> (connectionTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> connectionTask.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Callable&lt;Connection&gt; callable = <span class="keyword">new</span> Callable&lt;Connection&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Connection <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> createConnection();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;Connection&gt; newTask = <span class="keyword">new</span> FutureTask&lt;Connection&gt;(callable);</span><br><span class="line">            connectionTask = pool.putIfAbsent(key, newTask);</span><br><span class="line">            <span class="keyword">if</span> (connectionTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                connectionTask = newTask;</span><br><span class="line">                connectionTask.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connectionTask.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Connection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当3个线程同时进入else语句块时，各自都创建了一个FutureTask，但是ConcurrentHashMap只会加入其中一个。第一个线程执行pool.putIfAbsent方法后返回null，然后connectionTask被赋值，接着就执行run方法去创建连接，最后get。后面的线程执行pool.putIfAbsent方法不会返回null，就只会执行get方法。</p><p>在并发的环境下，通过FutureTask作为中间转换，成功实现了让某个方法只被一个线程执行。当然这个还是有缺陷: 多个线程同时调用get方法时，得到的是同一个数据库连接的多个引用，这会导致严重的问题。这是另外一个问题, 就不再多说.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。&lt;/p&gt;
&lt;p&gt;实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。&lt;/p&gt;
&lt;p&gt;但是，子线程执行的结果是要返回厨具的，而ru
      
    
    </summary>
    
      <category term="java" scheme="http://huleski.github.com/categories/java/"/>
    
    
      <category term="java" scheme="http://huleski.github.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Github上一款star过万的神器-thefuck</title>
    <link href="http://huleski.github.com/2019/03/25/Github%E4%B8%8A%E4%B8%80%E6%AC%BEstar%E8%BF%87%E4%B8%87%E7%9A%84%E7%A5%9E%E5%99%A8-thefuck/"/>
    <id>http://huleski.github.com/2019/03/25/Github上一款star过万的神器-thefuck/</id>
    <published>2019-03-25T11:41:43.000Z</published>
    <updated>2019-04-01T12:09:27.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>The Fuck is a magnificent app, inspired by a @liamosaur tweet, that corrects errors in previous console commands.</p></blockquote><p><img src="https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif" alt=""></p><p><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">项目地址</a>, 它可以帮你纠正大部分的命令行输入错误 </p><ul><li>想要返回上一级目录, 手速过快（你懂得）输成了<code>cd..</code>？ 。。。</li><li>想查看数据库的运行状态, 忘记单词拼写 (^_^;) <code>systecl status mysql</code>？ 。。。</li></ul><p>以上这些都不是问题, <strong><code>fuck</code></strong> 一下就好了, 就像你遇到bug了, 大喊一声: <strong>艹</strong>(第四声)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装环境是CentOS7, <code>The Fuck</code>的环境要求:</p><ul><li>python (3.4+)</li><li>pip</li><li>python-dev</li></ul><p>由于CentOS 7 默认安装了python2.7.5, 一些命令要用它比如yum, 因此我们需要安装python3并与python2共存</p><p>查看是否已经安装python, 使用命令: <code>python -V</code>. 使用命令: <code>which python</code> 查看python可执行文件的位置, 我的是在 <code>/usr/bin</code> 目录下, 切换到该目录下执行: <code>ll python*</code>命令查看</p><p>里面会有个python2和python软链接, python指向的是python2.7, 因为我们要装python3, 所以python要指向python3才行, 我们后面需要对它进行备份, 先<strong>安装相关环境</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure></p><p>备份:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv python python.bak</span><br></pre></td></tr></table></figure></p><p><strong>安装python3</strong></p><p>获取安装包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz</span><br></pre></td></tr></table></figure></p><p>下载完成, 解压:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvJf  Python-3.6.8.tar.xz</span><br></pre></td></tr></table></figure></p><p>切换进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.8</span><br></pre></td></tr></table></figure></p><p>编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>安装完毕，/usr/local/目录下就会有python3了</p><p>因此我们可以添加软链到执行目录下/usr/bin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure></p><p>再去<code>/usr/bin</code>目录下, 可以看到已经创建了一个指向python3的软链接python,测试是否安装成功:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure></p><p>看看输出的是不是python3的版本, 再执行 <code>python2</code> -V` 看到的就是python2的版本</p><p>因为执行yum需要python2版本，所以我们还要修改yum的配置，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/yum</span><br></pre></td></tr></table></figure></p><p>把 <code>#! /usr/bin/python</code> 修改为#! <code>/usr/bin/python2</code></p><p>同理 <code>vi /usr/libexec/urlgrabber-ext-down</code> 文件里面的 <code>#! /usr/bin/python</code> 也要修改为<code>#! /usr/bin/python2</code></p><p>现在python3已经安装成功, 同时python2也存在</p><p><strong>安装pip并升级pip工具</strong></p><ol><li>方法一: 直接安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-pip</span><br><span class="line">pip install --upgrade pip setuptools</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二: python3安装完成后默认已经带有pip, 你可以用以下命令,创建软链接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip /usr/bin/pip</span><br></pre></td></tr></table></figure><p><strong>安装python-dev</strong></p><p>需要注意的是: 在centOS7中该模块叫 <strong>python-devel</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-devel</span><br></pre></td></tr></table></figure><p><strong>安装thefuck</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install thefuck</span><br></pre></td></tr></table></figure><p>修改文件 <code>vim /usr/bin/thefuck</code>, 把第一行的 <code>#!/usr/bin/python2</code> 改成 <code>#!/usr/bin/python</code></p><p>查看thefuck是否安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuck -v</span><br></pre></td></tr></table></figure><p>如果看到如下信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Fuck 3.28 using Python 3.6.8 and Bash 4.2.46(2)-release</span><br></pre></td></tr></table></figure></p><p>则安装成功<br>下面我们来试一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost usr]# pwf</span><br><span class="line">bash: pwf: 未找到命令...</span><br><span class="line">[root@localhost usr]# fuck</span><br><span class="line">​​​​​​​​​​pwd [enter/↑/↓/ctrl+c]</span><br><span class="line">/usr</span><br><span class="line">[root@localhost usr]#</span><br></pre></td></tr></table></figure></p><p>OK! 以后有问题<code>fuck</code>一下就好了ヽ(￣▽￣)ﾉ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;The Fuck is a magnificent app, inspired by a @liamosaur t
      
    
    </summary>
    
      <category term="Github" scheme="http://huleski.github.com/categories/Github/"/>
    
    
      <category term="Github" scheme="http://huleski.github.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁机制</title>
    <link href="http://huleski.github.com/2019/03/24/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://huleski.github.com/2019/03/24/mysql锁机制/</id>
    <published>2019-03-24T15:23:39.000Z</published>
    <updated>2019-04-03T01:26:23.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。<br>MySQL大致可归纳为以下3种锁：</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><h2 id="MySQL表级锁的锁模式（MyISAM"><a href="#MySQL表级锁的锁模式（MyISAM" class="headerlink" title="MySQL表级锁的锁模式（MyISAM)"></a>MySQL表级锁的锁模式（MyISAM)</h2><p>MySQL表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）。</p><ul><li>对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li><li>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</li><li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</li></ul><p>当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p><p><strong>MySQL表级锁的锁模式</strong></p><p>ＭySQL的表锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。锁模式的兼容如下表</p><table><thead><tr><th>请求锁模式/是否兼容</th><th>None</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>是</td><td>否</td></tr><tr><td>写锁</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>可见，对ＭyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对ＭyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；ＭyISAM表的读和写操作之间，以及写和写操作之间是串行的！（<strong>当一线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</strong>）</p><p><strong>如何加表锁</strong></p><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预</p><p>给MyISAM表显示加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表order_detail，其中记录有订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</span><br></pre></td></tr></table></figure><p>这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">tables</span> orders <span class="keyword">read</span> <span class="keyword">local</span>,order_detail <span class="keyword">read</span> <span class="keyword">local</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><ul><li>上面的例子在LOCK TABLES时加了‘local’选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾插入记录</li><li>在用LOCKTABLES给表显式加表锁是时，必须同时取得所有涉及表的锁，并且MySQL支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MySQL问题一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</li></ul><p>一个session使用LOCK TABLE 命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。</p><p>当使用LOCK TABLE时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁多少次，否则也会出错！</p><p><strong>并发锁</strong></p><p>在一定条件下，MyISAM也支持查询和操作的并发进行。MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。</p><ul><li>当concurrent_insert设置为0时，不允许并发插入。</li><li>当concurrent_insert设置为1时，如果MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li><li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。</li></ul><p>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收到因删除记录而产生的中间空洞。</p><p><strong>MyISAM的锁调度</strong></p><p>前面讲过，MyISAM存储引擎的读和写锁是互斥，读操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。</p><ul><li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li><li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li></ul><p>虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。</p><p>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p><p>这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题。因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p><h2 id="InnoDB锁问题"><a href="#InnoDB锁问题" class="headerlink" title="InnoDB锁问题"></a>InnoDB锁问题</h2><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p><p><strong>1.事务（Transaction）及其ACID属性</strong></p><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p><ul><li>原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><p><strong>2.并发事务带来的问题</strong></p><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p><ul><li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li><li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li><li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li>幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li></ul><p><strong>3.事务隔离级别</strong></p><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种:</p><p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p><p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾</p><p><strong>事务４种隔离级别比较</strong></p><table><thead><tr><th>隔离级别</th><th>读数据一致性及允许的并发副作用</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交度（Read committed）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（Repeatable read）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化（Serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>最后要说明的是：各具体数据库并不一定完全实现了上述４个隔离级别，例如，Oracle只提供Read committed和Serializable两个标准级别，另外还自己定义的Read only隔离级别：SQL Server除支持上述ISO/ANSI SQL92定义的４个级别外，还支持一个叫做＂快照＂的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。ＭySQL支持全部４个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级下是采用MVCC一致性读，但某些情况又不是。</p><p><strong>获取InonoD行锁争用情况</strong></p><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Innodb_row_lock_current_waits | 0 |</span><br><span class="line">| Innodb_row_lock_time | 0 |</span><br><span class="line">| Innodb_row_lock_time_avg | 0 |</span><br><span class="line">| Innodb_row_lock_time_max | 0 |</span><br><span class="line">| Innodb_row_lock_waits | 0 |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p> 如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p><h2 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h2><p>InnoDB实现了以下两种类型的行锁。</p><ul><li>共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。</li></ul><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p><strong>InnoDB行锁模式兼容性列表</strong></p><table><thead><tr><th>当前锁模式/是否兼容/请求锁模式</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。</p><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB会自动给涉及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。</p><ul><li>共享锁（Ｓ）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</li><li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE</li></ul><p>用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p><p><strong>InnoDB行锁实现方式</strong></p><p> InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p><strong>间隙锁（Next-Key锁）</strong></p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid &gt; <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p><strong>什么时候使用表锁</strong></p><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在特殊事务中，也可以考虑使用表级锁。</p><ul><li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。在InnoDB下 ，使用表锁要注意以下两点。</p><ol><li>使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</li><li>在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line">LOCAK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[<span class="keyword">do</span> something with tables t1 and here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p><strong>关于死锁</strong></p><p>ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。</p><p>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</p><p> 通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。</p><ol><li>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。</li><li>在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。</li><li>当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</li></ol><p>尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。</p><p>如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于ＭyISAM的表锁，主要有以下几点</p><ol><li>共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</li><li>在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</li><li>ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</li><li>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</li></ol><p>对于InnoDB表，主要有以下几点</p><ol><li>InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</li><li>InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</li><li>在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</li><li>ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</li><li>锁冲突甚至死锁很难完全避免。</li></ol><p>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p><ul><li>尽量使用较低的隔离级别</li><li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li><li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul><p><a href="https://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。&lt;br&gt;MySQL大致可归纳为以下3种锁：&lt;
      
    
    </summary>
    
      <category term="mysql" scheme="http://huleski.github.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://huleski.github.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>docker块速搭建l2tp VPN服务器</title>
    <link href="http://huleski.github.com/2019/03/20/docker%E5%9D%97%E9%80%9F%E6%90%AD%E5%BB%BAl2tp-VPN%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://huleski.github.com/2019/03/20/docker块速搭建l2tp-VPN服务器/</id>
    <published>2019-03-20T10:57:23.000Z</published>
    <updated>2019-07-09T07:16:59.115Z</updated>
    
    <content type="html"><![CDATA[<p>参考: <a href="https://blog.csdn.net/xindoo/article/details/52830609" target="_blank" rel="noopener">docker快速搭建l2tp VPN服务器</a></p><p> docker就像一个大仓库, 我们只要从仓库中取出我们需要的应用(vpn服务器)运行起来就能用了。服务器是国外云服务器, 系统是CentOS7</p><h2 id="搭建vpn服务器"><a href="#搭建vpn服务器" class="headerlink" title="搭建vpn服务器"></a>搭建vpn服务器</h2><p><strong>1. 获取 l2tp 的镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fcojean/l2tp-ipsec-vpn-server</span><br></pre></td></tr></table></figure></p><p><strong>2. 配置PSK，用户名和密码。先创建配置文件vpn.env</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim vpn.env</span><br></pre></td></tr></table></figure></p><p>将一下配置复制到vpn.env文件中。该配置psk为“abcdefg”，两个用户名user1和user2，密码都为123456<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VPN_IPSEC_PSK=abcdefg</span><br><span class="line">VPN_USER_CREDENTIAL_LIST=[&#123;&quot;login&quot;:&quot;user1&quot;,&quot;password&quot;:&quot;123456&quot;&#125;,&#123;&quot;login&quot;:&quot;user2&quot;,&quot;password&quot;:&quot;123456&quot;&#125;]</span><br></pre></td></tr></table></figure></p><p><strong>3. 加载 IPsec NETKEY 内核模块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe af_key</span><br></pre></td></tr></table></figure></p><p><strong>4. 启动镜像</strong></p><p>该命令加载env文件做配置文件，并将对应端口和服务器的端口做绑定。<br>注意：在执行该命令时当前目录下必须有之前创建的vpn.env文件，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name vpn-server \</span><br><span class="line">    --env-file ./vpn.env \</span><br><span class="line">    -p 500:500/udp \</span><br><span class="line">    -p 4500:4500/udp \</span><br><span class="line">    -v /lib/modules:/lib/modules:ro \</span><br><span class="line">    -d --privileged \</span><br><span class="line">    fcojean/l2tp-ipsec-vpn-server</span><br></pre></td></tr></table></figure></p><p>查看当前的vpn服务是否正常启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs vpn-server</span><br></pre></td></tr></table></figure></p><p>有如下输出则表示已正常启动vpn服务器。</p><p><img src="http://pubgmjp23.bkt.clouddn.com/20180708143943177.png" alt="启动vpn"></p><p><strong>5. 关闭防火墙，先查看防火墙状态</strong></p><p>如果防火墙未开启则跳过此部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></p><p>除了关闭防火墙，云服务器还需要配置访问规则, 即开放端口, 一定要记得<strong>开放500端口和4500端口</strong>, 这两个端口是vpn使用的</p><h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><p>Windows10系统, 设置VPN:</p><ol><li>右键单击系统托盘中的无线/网络图标。 </li><li>选择 打开网络与共享中心。 </li><li>单击 设置新的连接或网络。 </li><li>选择 连接到工作区，然后单击 下一步。 </li><li>单击 使用我的Internet连接 (VPN)。 </li><li>在 Internet地址 字段中输入你的 VPN 服务器 IP。 </li><li>在 目标名称 字段中输入任意内容。单击 创建。 </li><li>返回 网络与共享中心。单击左侧的 更改适配器设置。 </li><li>右键单击新创建的 VPN 连接:</li></ol><p><img src="http://pubgmjp23.bkt.clouddn.com/20180707181238162.png" alt=""></p><p><img src="http://pubgmjp23.bkt.clouddn.com/20180707181543103.png" alt=""></p><ol start="10"><li>填写之前创建的vpn服务器ip, PSK, 用户名和密码, 点击保存. 注意VPN类型选择 [使用预共享秘钥的L2TP/IPSec PSK]</li><li>以管理员身份启用命令提示符：执行以下两条命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Services\PolicyAgent /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 0x2 /f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Services\RasMan\Parameters /v ProhibitIpSec /t REG_DWORD /d 0x0 /f</span><br></pre></td></tr></table></figure><ol start="12"><li><p>设置VPN连接属性.请参考: <a href="https://blog.csdn.net/qq_37729885/article/details/80577877" target="_blank" rel="noopener">win10设置VPN连接</a> </p></li><li><p>至此, 设置完毕, 请关机重启, 再点击连接VPN, 成功! (下图为方便说明, 连接了两个VPN)</p></li></ol><p><img src="http://pubgmjp23.bkt.clouddn.com/20180707182606548.png" alt=""></p><p>安卓手机不用设置可以直接连VPN, 但注意vpn类型选择 L2TP/IPSec PSK,<strong> 建议先用安卓手机</strong>（连WiFi，流量可能有意外）检测vpn是否搭建成功, 再尝试Windows10连接VPN</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考: &lt;a href=&quot;https://blog.csdn.net/xindoo/article/details/52830609&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker快速搭建l2tp VPN服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; dock
      
    
    </summary>
    
      <category term="VPN" scheme="http://huleski.github.com/categories/VPN/"/>
    
    
      <category term="VPN" scheme="http://huleski.github.com/tags/VPN/"/>
    
      <category term="docker" scheme="http://huleski.github.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker搭建gitlab-ce中文版详细教程</title>
    <link href="http://huleski.github.com/2019/03/19/docker%E6%90%AD%E5%BB%BAgitlab-ce%E4%B8%AD%E6%96%87%E7%89%88%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <id>http://huleski.github.com/2019/03/19/docker搭建gitlab-ce中文版详细教程/</id>
    <published>2019-03-19T11:56:29.000Z</published>
    <updated>2019-07-09T07:17:02.344Z</updated>
    
    <content type="html"><![CDATA[<p>我是在本机局域网搭建的gitlab,  切记<strong>服务器配置不能太低</strong>, gitlab比较耗资源, 这也是它功能强大的来源, 搭建环境:</p><ul><li>系统: centOS7, 8G内存, i5处理器</li><li>ip: 10.12.2.22</li><li>预留端口: 8090</li></ul><h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1.获取镜像"></a>1.获取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull beginor/gitlab-ce:11.0.1-ce.0</span><br></pre></td></tr></table></figure><p>查看镜像, 有1.5G大小</p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-4bcae9df30615e9f.png" alt="查看gitlab镜像"></p><h2 id="2-运行镜像"><a href="#2-运行镜像" class="headerlink" title="2.运行镜像"></a>2.运行镜像</h2><p>由于是docker镜像运行, 所以我们需要把gitlab的配置, 数据, 日志存到容器外面, 即将其挂载到宿主机。<br>先准备三个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/software/gitlab/etc</span><br><span class="line">mkdir -p /home/software/gitlab/logs</span><br><span class="line">mkdir -p /home/software/gitlab/data</span><br></pre></td></tr></table></figure></p><p>准备好这三个目录之后， 就可以开始运行 Docker 镜像了。完整的运行命令如下 ( <a href="https://docs.gitlab.com/omnibus/docker/" target="_blank" rel="noopener">查看更多详细配置</a> )：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 8443:443 \    # 映射https端口, 不过本文中没有用到</span><br><span class="line">--publish 8090:80 \      # 映射宿主机8090端口到容器中80端口</span><br><span class="line">--publish 8022:22 \      # 映射22端口, 可不配</span><br><span class="line">--name gitlab \            </span><br><span class="line">--restart always \</span><br><span class="line">--hostname 10.12.2.22 \    # 局域网宿主机的ip, 如果是公网主机可以写域名</span><br><span class="line">-v /home/software/gitlab/etc:/etc/gitlab \    # 挂载gitlab的配置文件</span><br><span class="line">-v /home/software/gitlab/logs:/var/log/gitlab \    # 挂载gitlab的日志文件</span><br><span class="line">-v /home/software/gitlab/data:/var/opt/gitlab \    # 挂载gitlab的数据</span><br><span class="line">-v /etc/localtime:/etc/localtime:ro \    # 保持宿主机和容器时间同步</span><br><span class="line">--privileged=true beginor/gitlab-ce    # 在容器中能以root身份执行操作</span><br></pre></td></tr></table></figure></p><p>这个时候已经搭建完了, 查看一下 ( 启动需要几分钟, 我大概启动了2分钟多 ) :</p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-ffc482d0a6a1fb2d.png" alt="查看gitlab运行状态"></p><p>看到状态显示为 <code>healthy</code> 就代表已经启动了, 这时候去访问 <a href="http://10.12.2.22:8090" target="_blank" rel="noopener">http://10.12.2.22:8090</a><br>第一次访问时，将被重定向到密码重置屏幕, 默认帐户的用户名是root, 登录后, 您可以更改用户名</p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-d70d7d9e3de6d8e9.png" alt="登录界面"></p><h2 id="3-配置gitlab"><a href="#3-配置gitlab" class="headerlink" title="3.配置gitlab"></a>3.配置gitlab</h2><p>要能充分使用gitlab, 必须配置邮件发送功能, 修改配置文件 gitlab.rb (启动镜像后产生的文件), 这里我配置的是QQ邮箱 ( <a href="https://docs.gitlab.com/omnibus/settings/smtp.html#smtp-settings" target="_blank" rel="noopener">查看其它邮箱配置</a> )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/software/gitlab/etc/gitlab.rb</span><br></pre></td></tr></table></figure></p><p>在文件的最后加上配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&apos;smtp_enable&apos;] = true</span><br><span class="line">gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.qq.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_port&apos;] = 465</span><br><span class="line">gitlab_rails[&apos;smtp_user_name&apos;] = &quot;fuck@qq.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_password&apos;] = &quot;授权码&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_domain&apos;] = &quot;smtp.qq.com&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;</span><br><span class="line">gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true</span><br><span class="line">gitlab_rails[&apos;smtp_tls&apos;] = true</span><br><span class="line">gitlab_rails[&apos;gitlab_email_from&apos;] = &apos;fuck@qq.com&apos;</span><br></pre></td></tr></table></figure></p><p>网上很多教程说要配置external_url, 我按照加了配置后gitlab反而异常了, 不管它, 用默认的就好了, 保存退出, 再另外开一个终端, 进入容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab /bin/bash</span><br></pre></td></tr></table></figure></p><p>此时已经进入docker容器了, 容器中执行命令重新配置gitlab:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure            # 重新配置</span><br></pre></td></tr></table></figure></p><p>现在可以测试邮件是否配置正确了, 同样容器中执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rails console   # 进入邮件控制台, 稍等一会才能进入</span><br><span class="line">Notify.test_email(&apos;baka@qq.com&apos;, &apos;Message Subject&apos;, &apos;Message Body&apos;).deliver_now  # 发送测试邮件</span><br></pre></td></tr></table></figure></p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-8672d7423144b20a.png" alt="测试gitlab邮件发送"></p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-c84daee944ffb48e.png" alt="邮件已经成功收到"></p><p>邮件配置已经完成了, 现在需要配置项目路径 (如果你预留的gitlab映射端口是80的话, 你已经配置完了), 在宿主机中 (容器外面) 修改文件gitlab.yml, 如果port不对, 要改过来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/software/gitlab/data/gitlab-rails/etc/gitlab.yml</span><br></pre></td></tr></table></figure></p><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-1ede73a0e00ee5a3.png" alt="修改ip端口"></p><p>改完之后在容器中重启gitlab就配置完成了。 注意: 此时<strong>不能</strong>再重新配置(gitlab-ctl reconfigure), 否则可能会改变刚修改的gitlab.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl restart     # 重启gitlab</span><br></pre></td></tr></table></figure></p><p><strong>gitlab常用命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 重新应用gitlab的配置</span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"> </span><br><span class="line"># 重启gitlab服务</span><br><span class="line">gitlab-ctl restart</span><br><span class="line"> </span><br><span class="line"># 查看gitlab运行状态</span><br><span class="line">gitlab-ctl status</span><br><span class="line"> </span><br><span class="line">#停止gitlab服务</span><br><span class="line">gitlab-ctl stop</span><br><span class="line"> </span><br><span class="line"># 查看gitlab运行日志</span><br><span class="line">gitlab-ctl tail</span><br></pre></td></tr></table></figure></p><p><strong>gitlab邮件没收到? 看这里</strong><br>如果没收到邮件, 有两个可能 :</p><ul><li>电脑没网络    (我就是犯了这个愚蠢的错误, 主机改成静态ip后没网了也不知道, 折腾了很久才发现)</li><li>邮件被当做垃圾邮件了    ( 去垃圾箱看看吧 -_-! )</li><li>邮箱密码错了, 注意是授权码哦</li></ul><p><strong>gitlab搭建前后对比</strong></p><ul><li>搭建前, 内存只占用了500多M</li><li>搭建后, 内存就占用了5G</li></ul><p><img src="http://pubgmjp23.bkt.clouddn.com/15856745-030a1594e4a710ac.png" alt="搭建gitlab后内存使用飙升"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我是在本机局域网搭建的gitlab,  切记&lt;strong&gt;服务器配置不能太低&lt;/strong&gt;, gitlab比较耗资源, 这也是它功能强大的来源, 搭建环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统: centOS7, 8G内存, i5处理器&lt;/li&gt;
&lt;li&gt;ip: 10.1
      
    
    </summary>
    
      <category term="gitlab" scheme="http://huleski.github.com/categories/gitlab/"/>
    
    
      <category term="docker" scheme="http://huleski.github.com/tags/docker/"/>
    
      <category term="gitlab" scheme="http://huleski.github.com/tags/gitlab/"/>
    
  </entry>
  
</feed>
